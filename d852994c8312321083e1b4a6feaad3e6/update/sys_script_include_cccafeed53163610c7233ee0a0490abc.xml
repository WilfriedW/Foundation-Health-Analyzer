<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHARuleEvaluator</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Apply issue rules to analyzed records</description>
        <mobile_callable>false</mobile_callable>
        <name>FHARuleEvaluator</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var FHARuleEvaluator = Class.create();
FHARuleEvaluator.prototype = {
    TABLES: {
        ISSUE_RULES: 'x_1310794_founda_0_issue_rules'
    },

    initialize: function() {
        this._ruleCache = {};
    },

    /**
     * Evaluates per-record rules
     * @param {Object} item - Item object with {sys_id, table, values}
     * @param {Array} rules - Rules to apply
     * @param {Object} context - Shared context
     * @returns {Array} - Issues found
     */
    evaluate: function(item, rules, context) {
        var allIssues = [];

        if (!rules || !Array.isArray(rules)) return allIssues;

        var self = this;

        rules.forEach(function(rule) {
            try {
                if (rule.execution_mode === "aggregate") return;

                var params = self._parseParams(rule.params);
                var issues = self._runScriptSafe(rule, item, params, context);

                if (issues && Array.isArray(issues)) {
                    allIssues = allIssues.concat(issues);
                }
            } catch (error) {
                gs.error(
                    "[FHARuleEvaluator] Error in rule " +
                    rule.code +
                    ": " +
                    error.message,
                );
            }
        });

        return allIssues;
    },

    /**
     * Evaluates aggregate rules (executed ONCE per table)
     * @param {String} tableName - Table to analyze
     * @param {Array} rules - Aggregate rules
     * @param {Object} context - Shared context
     * @returns {Array} - Issues found
     */
    evaluateAggregate: function(tableName, rules, context) {
        var allIssues = [];

        if (!rules || !Array.isArray(rules)) return allIssues;

        var self = this;

        rules.forEach(function(rule) {
            try {
                if (rule.execution_mode !== "aggregate") return;

                var params = self._parseParams(rule.params);
                var issues = self._runAggregateScript(rule, tableName, params, context);

                if (issues && Array.isArray(issues)) {
                    allIssues = allIssues.concat(issues);
                }
            } catch (error) {
                gs.error(
                    "[FHARuleEvaluator] Error in aggregate rule " +
                    rule.code +
                    ": " +
                    error.message,
                );
            }
        });

        return allIssues;
    },

    /**
     * Executes per-record rule script
     */
    _runScriptSafe: function(rule, item, params, context) {
        var issues = [];

        try {
            var ruleGr = this._getRuleGlideRecord(rule.sys_id);
            if (!ruleGr) {
                gs.error("[FHARuleEvaluator] Rule not found: " + rule.sys_id);
                return issues;
            }

            var evaluator = new GlideScopedEvaluator();

            var ruleObj = {
                sys_id: rule.sys_id,
                code: rule.code,
                name: rule.name,
                severity: rule.severity || rule.default_severity || "medium",
                message_template: rule.message_template,
                table: rule.table,
            };

            // Inject variables
            evaluator.putVariable("params", params);
            evaluator.putVariable("rule", ruleObj);
            evaluator.putVariable("item", item);
            evaluator.putVariable("context", context || {});
            evaluator.putVariable("issues", issues);
            evaluator.putVariable("buildIssue", this._buildIssueFactory(ruleObj, item));

            evaluator.evaluateScript(ruleGr, "script");

            // Retrieve issues
            var retrievedIssues = evaluator.getVariable("issues");

            if (retrievedIssues && Array.isArray(retrievedIssues)) {
                issues = retrievedIssues;
            }
        } catch (error) {
            gs.error(
                "[FHARuleEvaluator] Script error in " +
                rule.code +
                ": " +
                error.message,
            );
        }

        return issues;
    },

    /**
     * Executes aggregate rule script
     * FIXED: Uses GlideRecord for evaluateScript()
     */
    _runAggregateScript: function(rule, tableName, params, context) {
        var issues = [];

        try {
            var ruleGr = this._getRuleGlideRecord(rule.sys_id);
            var evaluator = new GlideScopedEvaluator();

            var ruleObj = {
                sys_id: rule.sys_id,
                code: rule.code,
                name: rule.name,
                severity: rule.severity || rule.default_severity || "medium",
                message_template: rule.message_template,
                table: rule.table,
            };

            // Inject variables for aggregate mode
            evaluator.putVariable("tableName", tableName);
            evaluator.putVariable("params", params);
            evaluator.putVariable("rule", ruleObj);
            evaluator.putVariable("context", context || {});
            evaluator.putVariable("issues", issues);
            evaluator.putVariable("buildIssue", this._buildIssueFactory(ruleObj, { sys_id: '', table: tableName }));

            evaluator.evaluateScript(ruleGr, "script");

            var retrievedIssues = evaluator.getVariable("issues");

            if (retrievedIssues && Array.isArray(retrievedIssues)) {
                issues = retrievedIssues;
            }
        } catch (error) {
            gs.error(
                "[FHARuleEvaluator] Aggregate script error in " +
                rule.code +
                ": " +
                error.message,
            );
        }

        return issues;
    },

    /**
     * Gets rule GlideRecord from cache or DB
     * Optimization: Cache to avoid multiple queries for same rule
     */
    _getRuleGlideRecord: function(ruleSysId) {
        // Check cache first
        if (this._ruleCache[ruleSysId]) {
            return this._ruleCache[ruleSysId];
        }

        // Load from DB
        var gr = new GlideRecord(this.TABLES.ISSUE_RULES);
        if (gr.get(ruleSysId)) {
            // Cache for reuse
            this._ruleCache[ruleSysId] = gr;
            return gr;
        }

        return null;
    },

    /**
     * Creates a buildIssue helper function bound to current rule/item context.
     * Injected into rule scripts via evaluator.putVariable("buildIssue", ...).
     * Usage in rule: issues.push(buildIssue(gr, 'message', { details }));
     * @param {Object} ruleObj - Rule object {sys_id, code, name, severity, ...}
     * @param {Object} itemObj - Item object {sys_id, table, values, ...}
     * @returns {Function} buildIssue(gr, message, details) function
     */
    _buildIssueFactory: function(ruleObj, itemObj) {
        return function(gr, message, details) {
            var recordName = '';
            if (gr && typeof gr.getValue === 'function') {
                recordName = gr.getValue('name') || gr.getValue('user_name') || gr.getValue('title') || gr.getUniqueValue();
            } else if (typeof gr === 'string') {
                recordName = gr;
            }

            var issueDetails = details || {};
            if (!issueDetails.record_name) {
                issueDetails.record_name = recordName || 'N/A';
            }

            return {
                code: ruleObj.code,
                message: message || 'Issue detected',
                severity: ruleObj.severity || 'medium',
                record: itemObj.sys_id,
                record_table: itemObj.table,
                details: issueDetails
            };
        };
    },

    _parseParams: function(paramsStr) {
        if (!paramsStr || paramsStr === '{}') return {};
        try {
            return JSON.parse(paramsStr);
        } catch (e) {
            gs.warn('[FHARuleEvaluator] Failed to parse rule params: ' + e.message);
            return {};
        }
    },

    type: "FHARuleEvaluator",
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-13 21:15:00</sys_created_on>
        <sys_id>cccafeed53163610c7233ee0a0490abc</sys_id>
        <sys_mod_count>72</sys_mod_count>
        <sys_name>FHARuleEvaluator</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_cccafeed53163610c7233ee0a0490abc</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-02-12 08:58:40</sys_updated_on>
    </sys_script_include>
</record_update>
