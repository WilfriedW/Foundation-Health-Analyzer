<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHCheckAutomation</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHCheckAutomation</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var FHCheckAutomation = Class.create();
FHCheckAutomation.prototype = {
    initialize: function() {
        this.optionsHandler = new FHOptionsHandler();
        this.utils = new FHScanUtils();
    },

    /**
     * execute(ctx)
     * Primary public entrypoint to execute automation checks.     *
     * @param {Object} ctx - FHAnalysisContext
     */
    execute: function(ctx) {
        //if (!ctx || !ctx.isTableExists || !ctx.isTableExists()) return;
		if (!ctx) return;

        // Register the automation category once (addCategoryAndMetrics auto-registers too)
        ctx.registerCategory('automation', 'Automation', 'fa-cogs');

        // Get tables to check from centralized context logic
        var tablesToCheck = ctx.getTablesToCheck();

        // Run individual checks 
        this.checkScheduledJobs(ctx, tablesToCheck);
        this.checkFlows(ctx, tablesToCheck);
        this.checkWorkflows(ctx, tablesToCheck);
        this.checkNotifications(ctx, tablesToCheck);
        this.checkUIActions(ctx, tablesToCheck);
        this.checkUIPolicies(ctx, tablesToCheck);
        this.checkInboundEmailActions(ctx, tablesToCheck);

        if (ctx.isDeepScanEnabled()) 
            this.optionsHandler.deepScanScripts(ctx);
        
        if (ctx.isAnalyzeReferencesEnabled())
            this.optionsHandler.analyzeIntegrationDependencies(ctx);
        
        if (ctx.isLdapEnabled()) 
            this.optionsHandler.analyzeLdapConfiguration(ctx);
    },


    // /**
    //  * Backward compatibility: execute() calls run()
    //  */
    // execute: function(ctx) {
    //     return this.run(ctx);
    // },

    /**
     * checkScheduledJobs(ctx, configTables)
     * Find scheduled jobs (sysauto_script) whose scripts reference our tables.
     */
    checkScheduledJobs: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var scheduledJobs = [];

        // Get jobs with scripts via utils (memoized)
        var jobs = this.utils.getRecords('sysauto_script', function(gr) {
            gr.addNotNullQuery('script');
        }, ['name', 'script', 'active', 'run_type'], 0, 'sysauto_script:with_script');

        for (var i = 0; i < jobs.length; i++) {
            var job = jobs[i];
            var scriptText = job.script || '';
            var matchedTable = null;
            for (var t = 0; t < configTables.length; t++) {
                if (scriptText.indexOf(configTables[t]) > -1) {
                    matchedTable = configTables[t];
                    break;
                }
            }
            if (!matchedTable) continue;

            var isActive = this.utils.toBool(job.active);
            scheduledJobs.push({
                sys_id: job.sys_id,
                name: job.name || 'Unnamed',
                active: isActive,
                inherited: matchedTable !== tableName,
                table: 'sysauto_script',
                matched_table: matchedTable,
                run_type: job.run_type || ''
            });

            if (!isActive) {
                ctx.addIssue('INACTIVE_SCHEDULED_JOB', 'Inactive scheduled job: "' + (job.name || 'Unnamed') + '"', 'low', {
                    record_table: 'sysauto_script',
                    record_sys_id: job.sys_id,
                    category: 'automation'
                });
            }
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'scheduled_job', 'Scheduled Jobs', scheduledJobs, {
            table: 'sysauto_script',
            icon: 'fa-clock',
            color: '#6f42c1'
        });
    },

    /**
     * checkFlows(ctx, configTables)
     * Check flows (sys_hub_flow) for trigger_table matching our config tables.
     */
    checkFlows: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var flows = [];

        try {
            var gr = new GlideRecord('sys_hub_flow');
            this.utils.addInQuery(gr, 'trigger_table', configTables);
            gr.query();
            while (gr.next()) {
                var flowName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
                var flowTable = ctx.safeGetValue(gr, 'trigger_table');
                var isActive = this.utils.toBool(gr.getValue('active'));
                flows.push({
                    sys_id: gr.getUniqueValue(),
                    name: flowName,
                    table: 'sys_hub_flow',
                    trigger_table: flowTable,
                    inherited: (flowTable !== tableName),
                    active: isActive,
                    trigger_type: ctx.safeGetValue(gr, 'trigger_type'),
                    description: ctx.safeGetValue(gr, 'description')
                });

                if (!isActive) {
                    ctx.addIssue('INACTIVE_FLOW', 'Inactive flow: "' + flowName + '"', 'low', {
                        record_table: 'sys_hub_flow',
                        record_sys_id: gr.getUniqueValue(),
                        category: 'automation'
                    });
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkFlows error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'flow', 'Flows', flows, {
            table: 'sys_hub_flow',
            icon: 'fa-project-diagram',
            color: '#17a2b8'
        });

        if (flows.length > 10) {
            ctx.addIssue('MANY_FLOWS', 'Table has ' + flows.length + ' flows. Check for redundancy.', 'medium', {
                record_table: 'sys_hub_flow',
                record_filter: 'trigger_tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * checkWorkflows(ctx, configTables)
     * Legacy workflows (wf_workflow) that target our tables.
     */
    checkWorkflows: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var workflows = [];

        try {
            var gr = new GlideRecord('wf_workflow');
            this.utils.addInQuery(gr, 'table', configTables);
            gr.query();
            while (gr.next()) {
                var wfName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
                var wfTable = ctx.safeGetValue(gr, 'table');
                var isActive = this.utils.toBool(gr.getValue('active'));
                var isPublished = this.utils.toBool(gr.getValue('published'));
                workflows.push({
                    sys_id: gr.getUniqueValue(),
                    name: wfName,
                    table: 'wf_workflow',
                    trigger_table: wfTable,
                    inherited: (wfTable !== tableName),
                    active: isActive,
                    published: isPublished,
                    description: ctx.safeGetValue(gr, 'description')
                });

                if (!isActive || !isPublished) {
                    var code = !isPublished ? 'UNPUBLISHED_WORKFLOW' : 'INACTIVE_WORKFLOW';
                    var msg = (!isPublished ? 'Unpublished' : 'Inactive') + ' workflow: "' + wfName + '"';
                    ctx.addIssue(code, msg, 'low', {
                        record_table: 'wf_workflow',
                        record_sys_id: gr.getUniqueValue(),
                        category: 'automation'
                    });
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkWorkflows error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'workflow', 'Workflows', workflows, {
            table: 'wf_workflow',
            icon: 'fa-project-diagram',
            color: '#6610f2'
        });

        if (workflows.length > 10) {
            ctx.addIssue('MANY_WORKFLOWS', 'Table has ' + workflows.length + ' workflows. Review for consolidation.', 'medium', {
                record_table: 'wf_workflow',
                record_filter: 'tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * checkNotifications(ctx, configTables)
     * Notifications that reference the table in conditions or scripts.
     */
    checkNotifications: function(ctx, configTables) {
        var notifications = [];
        try {
            var gr = new GlideRecord('sysevent_email_action'); // notifications table
            gr.addNotNullQuery('condition'); // likely to have conditions referencing fields
            gr.query();
            while (gr.next()) {
                var name = ctx.safeGetValue(gr, 'name') || 'Unnamed';
                var condition = ctx.safeGetValue(gr, 'condition') || '';
                var script = ctx.safeGetValue(gr, 'script') || '';
                var related = false;
                for (var t = 0; t < configTables.length; t++) {
                    if (condition.indexOf(configTables[t]) > -1 || script.indexOf(configTables[t]) > -1) {
                        related = true;
                        break;
                    }
                }
                if (!related) continue;

                var isActive = this.utils.toBool(gr.getValue('active'));
                notifications.push({
                    sys_id: gr.getUniqueValue(),
                    name: name,
                    table: 'sysevent_email_action',
                    active: isActive,
                    condition: condition
                });

                if (!isActive) {
                    ctx.addIssue('INACTIVE_NOTIFICATION', 'Inactive notification: "' + name + '"', 'low', {
                        record_table: 'sysevent_email_action',
                        record_sys_id: gr.getUniqueValue(),
                        category: 'automation'
                    });
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkNotifications error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'notification', 'Notifications', notifications, {
            table: 'sysevent_email_action',
            icon: 'fa-bell',
            color: '#ffc107'
        });
    },

    /**
     * checkUIActions(ctx, configTables)
     * UI Actions (sys_ui_action) related to our tables.
     */
    checkUIActions: function(ctx, configTables) {
        var uiActions = [];
        try {
            var gr = new GlideRecord('sys_ui_action');
            this.utils.addInQuery(gr, 'table', configTables);
            gr.query();
            while (gr.next()) {
                var name = ctx.safeGetValue(gr, 'name') || 'Unnamed';
                var active = this.utils.toBool(gr.getValue('active'));
                var table = ctx.safeGetValue(gr, 'table');
                var actionType = ctx.safeGetValue(gr, 'type');
                var script = ctx.safeGetValue(gr, 'script') || '';
                uiActions.push({
                    sys_id: gr.getUniqueValue(),
                    name: name,
                    table: 'sys_ui_action',
                    target_table: table,
                    inherited: (table !== ctx.getTableName()),
                    active: active,
                    type: actionType,
                    script: script
                });

                if (!active) {
                    ctx.addIssue('INACTIVE_UI_ACTION', 'Inactive UI Action: "' + name + '"', 'low', {
                        record_table: 'sys_ui_action',
                        record_sys_id: gr.getUniqueValue(),
                        category: 'automation'
                    });
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkUIActions error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'ui_action', 'UI Actions', uiActions, {
            table: 'sys_ui_action',
            icon: 'fa-mouse-pointer',
            color: '#007bff'
        });

        if (uiActions.length > 25) {
            ctx.addIssue('MANY_UI_ACTIONS', 'Table has ' + uiActions.length + ' UI Actions. Interface may be overloaded.', 'medium', {
                record_table: 'sys_ui_action',
                record_filter: 'tableIN' + configTables.join(','),
                category: 'ui'
            });
        }
    },

    /**
     * checkUIPolicies(ctx, configTables)
     * UI Policies (sys_ui_policy) for the tables.
     */
    checkUIPolicies: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var uiPolicies = [];

        try {
            var gr = new GlideRecord('sys_ui_policy');
            this.utils.addInQuery(gr, 'table', configTables);
            gr.query();
            while (gr.next()) {
                var policyTable = ctx.safeGetValue(gr, 'table');
                var name = ctx.safeGetValue(gr, 'short_description') || 'Unnamed';
                var isActive = this.utils.toBool(gr.getValue('active'));
                uiPolicies.push({
                    sys_id: gr.getUniqueValue(),
                    name: name,
                    table: 'sys_ui_policy',
                    trigger_table: policyTable,
                    inherited: (policyTable !== tableName),
                    active: isActive,
                    on_load: ctx.safeGetValue(gr, 'on_load') === 'true',
                    reverse_if_false: ctx.safeGetValue(gr, 'reverse_if_false') === 'true',
                    global: ctx.safeGetValue(gr, 'global') === 'true'
                });
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkUIPolicies error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'ui_policy', 'UI Policies', uiPolicies, {
            table: 'sys_ui_policy',
            icon: 'fa-shield-alt',
            color: '#20c997'
        });

        if (uiPolicies.length > 15) {
            ctx.addIssue('MANY_UI_POLICIES', 'Table has ' + uiPolicies.length + ' active UI Policies. This may slow down form loading.', 'medium', {
                record_table: 'sys_ui_policy',
                record_filter: 'tableIN' + configTables.join(',') + '^active=true',
                category: 'ui'
            });
        }
    },

    /**
     * checkInboundEmailActions(ctx, configTables)
     * Check inbound email actions and flow trigger instances related to email.
     */
    checkInboundEmailActions: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var inboundEmails = [];

        // sysevent_in_email_action
        try {
            var gr = new GlideRecord('sysevent_in_email_action');
            if (gr.isValid()) {
                this.utils.addInQuery(gr, 'table', configTables);
                gr.query();
                while (gr.next()) {
                    var emailTable = ctx.safeGetValue(gr, 'table');
                    var isActive = this.utils.toBool(gr.getValue('active'));
                    inboundEmails.push({
                        sys_id: gr.getUniqueValue(),
                        name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                        table: 'sysevent_in_email_action',
                        trigger_table: emailTable,
                        inherited: (emailTable !== tableName),
                        active: isActive,
                        type: ctx.safeGetValue(gr, 'type'),
                        action_type: ctx.safeGetValue(gr, 'action_type'),
                        stop_processing: ctx.safeGetValue(gr, 'stop_processing') === 'true'
                    });

                    if (!isActive) {
                        ctx.addIssue('INACTIVE_INBOUND_EMAIL', 'Inactive inbound email action: "' + (ctx.safeGetValue(gr, 'name') || 'Unnamed') + '"', 'low', {
                            record_table: 'sysevent_in_email_action',
                            record_sys_id: gr.getUniqueValue(),
                            category: 'automation'
                        });
                    }
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkInboundEmailActions (sysevent_in_email_action) error: ' + (e && e.message));
        }

        // sys_hub_trigger_instance (flow triggers including email)
        try {
            // For each configured table we look for trigger instances that reference it
            for (var i = 0; i < configTables.length; i++) {
                var tableToCheck = configTables[i];
                var trigGr = new GlideRecord('sys_hub_trigger_instance');
                if (!trigGr.isValid()) continue;
                trigGr.addQuery('trigger_type', 'IS', 'email');
                // Many trigger instances store trigger_config or caches - search in trigger_config
                trigGr.addQuery('trigger_config', 'LIKE', tableToCheck);
                trigGr.query();
                while (trigGr.next()) {
                    var triggerConfig = ctx.safeGetValue(trigGr, 'trigger_config') || '';
                    var related = false;
                    for (var t = 0; t < configTables.length; t++) {
                        if (triggerConfig.indexOf(configTables[t]) > -1) {
                            related = true;
                            break;
                        }
                    }
                    if (!related) continue;

                    var flowRef = trigGr.getValue('flow');
                    var flowName = '';
                    if (flowRef) {
                        var flowRecord = this.utils.getRecordBySysId('sys_hub_flow', flowRef, ['name']);
                        if (flowRecord) flowName = flowRecord.name || '';
                    }

                    inboundEmails.push({
                        sys_id: trigGr.getUniqueValue(),
                        name: flowName || 'Flow Trigger',
                        table: 'sys_hub_trigger_instance',
                        trigger_table: tableToCheck,
                        inherited: false,
                        active: true,
                        type: 'flow_trigger',
                        action_type: 'email',
                        stop_processing: false
                    });
                }
            }
        } catch (e) {
            gs.error('FHCheckAutomation.checkInboundEmailActions (trigger instances) error: ' + (e && e.message));
        }

        this.utils.addCategoryAndMetrics(ctx, 'automation', 'inbound_email', 'Inbound Email Actions', inboundEmails, {
            table: 'sysevent_in_email_action',
            icon: 'fa-inbox',
            color: '#e83e8c'
        });

        if (inboundEmails.length > 10) {
            ctx.addIssue('MANY_INBOUND_EMAILS', 'Table has ' + inboundEmails.length + ' inbound email actions. Review for efficiency.', 'low', {
                record_table: 'sysevent_in_email_action',
                record_filter: 'target_tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    type: 'FHCheckAutomation'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-02 23:21:10</sys_created_on>
        <sys_id>7209c240835a321083e1b4a6feaad310</sys_id>
        <sys_mod_count>21</sys_mod_count>
        <sys_name>FHCheckAutomation</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_7209c240835a321083e1b4a6feaad310</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-05 01:53:50</sys_updated_on>
    </sys_script_include>
</record_update>
