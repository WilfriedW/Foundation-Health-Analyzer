<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHCheckAutomation</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHCheckAutomation</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * FHCheckAutomation - Check for automation issues
 * Analyzes scheduled jobs, flows, workflows, and notifications
 */
var FHCheckAutomation = Class.create();
FHCheckAutomation.prototype = {
    
    /**
     * Safe getValue - returns empty string if null
     * @private
     */
    _safeGetValue: function(gr, field) {
        var val = gr.getValue(field);
        return (val === null || val === undefined) ? '' : String(val);
    },

    /**
     * Execute the check
     * @param {Object} ctx - Analysis context
     */
    execute: function(ctx) {
        if (!ctx.metrics.table_exists) return;
        
        this._checkScheduledJobs(ctx);
        this._checkFlows(ctx);
        this._checkWorkflows(ctx);
        this._checkNotifications(ctx);
        this._checkUIActions(ctx);
        this._checkUIPolicies(ctx);
    },

    /**
     * Check scheduled jobs that reference this table
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkScheduledJobs: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var scheduledJobs = [];
        var self = this;
        
        // Check sys_trigger for scheduled jobs
        var gr = new GlideRecord('sysauto_script');
        gr.addQuery('script', 'CONTAINS', tableName);
        gr.query();
        
        while (gr.next()) {
            var jobName = self._safeGetValue(gr, 'name') || 'Unnamed';
            // Check active field - can be 'true', '1', or boolean
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
            
            var jobInfo = {
                sys_id: gr.getUniqueValue(),
                name: jobName,
                active: isActive,
                run_type: self._safeGetValue(gr, 'run_type'),
                next_action: self._safeGetValue(gr, 'next_action')
            };
            scheduledJobs.push(jobInfo);
            
            if (!isActive) {
                ctx.addIssue('INACTIVE_SCHEDULED_JOB', 'Inactive scheduled job: "' + jobName + '"', 'low', {
                    record_table: 'sysauto_script',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'automation'
                });
            }
        }
        
        ctx.metrics.scheduled_jobs = scheduledJobs;
        ctx.metrics.scheduled_job_count = scheduledJobs.length;
    },

    /**
     * Check Flow Designer flows for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkFlows: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var flows = [];
        var self = this;
        
        // Get all tables in hierarchy (current table + parent tables)
        var tablesToCheck = self._getTableHierarchy(tableName);
        
        // Check for flows triggered by this table or parent tables
        try {
            var gr = new GlideRecord('sys_hub_flow');
            if (gr.isValid()) {
                gr.addQuery('trigger_table', 'IN', tablesToCheck.join(','));
                gr.query();
                
                while (gr.next()) {
                    var flowName = self._safeGetValue(gr, 'name') || 'Unnamed';
                    var flowTable = self._safeGetValue(gr, 'trigger_table');
                    // Check active field - can be 'true', '1', or boolean
                    var activeVal = gr.getValue('active');
                    var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
                    
                    var flowInfo = {
                        sys_id: gr.getUniqueValue(),
                        name: flowName,
                        table: flowTable,
                        inherited: (flowTable !== tableName),
                        active: isActive,
                        trigger_type: self._safeGetValue(gr, 'trigger_type'),
                        description: self._safeGetValue(gr, 'description')
                    };
                    flows.push(flowInfo);
                    
                    if (!isActive) {
                        ctx.addIssue('INACTIVE_FLOW', 'Inactive flow: "' + flowName + '"', 'low', {
                            record_table: 'sys_hub_flow',
                            record_sys_id: gr.getUniqueValue(),
                            category: 'automation'
                        });
                    }
                }
            }
        } catch (e) {
            // Flow Designer table might not exist in all instances
        }
        
        ctx.metrics.flows = flows;
        ctx.metrics.flow_count = flows.length;
        ctx.metrics.flow_direct_count = flows.filter(function(f) { return !f.inherited; }).length;
        ctx.metrics.flow_inherited_count = flows.filter(function(f) { return f.inherited; }).length;
        
        if (flows.length > 10) {
            ctx.addIssue('MANY_FLOWS', 'Table has ' + flows.length + ' flows (' + ctx.metrics.flow_direct_count + ' direct, ' + ctx.metrics.flow_inherited_count + ' inherited). Check for redundancy.', 'medium', {
                record_table: 'sys_hub_flow',
                record_filter: 'trigger_tableIN' + tablesToCheck.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * Check legacy workflows for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkWorkflows: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var workflows = [];
        var self = this;
        
        // Get all tables in hierarchy (current table + parent tables)
        var tablesToCheck = self._getTableHierarchy(tableName);
        
        var gr = new GlideRecord('wf_workflow');
        gr.addQuery('table', 'IN', tablesToCheck.join(','));
        gr.query();
        
        while (gr.next()) {
            var wfName = self._safeGetValue(gr, 'name') || 'Unnamed';
            var wfTable = self._safeGetValue(gr, 'table');
            // Check active and published fields
            var activeVal = gr.getValue('active');
            var publishedVal = gr.getValue('published');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
            var isPublished = (publishedVal === 'true' || publishedVal === '1' || publishedVal === true);
            
            var wfInfo = {
                sys_id: gr.getUniqueValue(),
                name: wfName,
                table: wfTable,
                inherited: (wfTable !== tableName),
                active: isActive,
                published: isPublished
            };
            workflows.push(wfInfo);
            
            // Check for unpublished active workflows
            if (isActive && !isPublished) {
                ctx.addIssue('UNPUBLISHED_WORKFLOW', 'Active but unpublished workflow: "' + wfName + '"', 'medium', {
                    record_table: 'wf_workflow',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'automation'
                });
            }
        }
        
        ctx.metrics.workflows = workflows;
        ctx.metrics.workflow_count = workflows.length;
        ctx.metrics.workflow_direct_count = workflows.filter(function(w) { return !w.inherited; }).length;
        ctx.metrics.workflow_inherited_count = workflows.filter(function(w) { return w.inherited; }).length;
        
        // Recommend migrating to Flow Designer if using legacy workflows
        if (workflows.length > 0) {
            ctx.addIssue('LEGACY_WORKFLOWS', 'Table uses ' + workflows.length + ' legacy workflow(s) (' + ctx.metrics.workflow_direct_count + ' direct, ' + ctx.metrics.workflow_inherited_count + ' inherited). Consider migrating to Flow Designer.', 'low', {
                record_table: 'wf_workflow',
                record_filter: 'tableIN' + tablesToCheck.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * Check notifications for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkNotifications: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var notifications = [];
        var self = this;
        
        // Get all tables in hierarchy (current table + parent tables)
        var tablesToCheck = self._getTableHierarchy(tableName);
        
        var gr = new GlideRecord('sysevent_email_action');
        gr.addQuery('collection', 'IN', tablesToCheck.join(','));
        gr.query();
        
        while (gr.next()) {
            var notifTable = self._safeGetValue(gr, 'collection');
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
            
            var notifInfo = {
                sys_id: gr.getUniqueValue(),
                name: self._safeGetValue(gr, 'name') || 'Unnamed',
                table: notifTable,
                inherited: (notifTable !== tableName),
                active: isActive,
                event_name: self._safeGetValue(gr, 'event_name'),
                send_self: self._safeGetValue(gr, 'send_self') === 'true'
            };
            notifications.push(notifInfo);
        }
        
        ctx.metrics.notifications = notifications;
        ctx.metrics.notification_count = notifications.length;
        ctx.metrics.notification_direct_count = notifications.filter(function(n) { return !n.inherited; }).length;
        ctx.metrics.notification_inherited_count = notifications.filter(function(n) { return n.inherited; }).length;
        
        if (notifications.length > 20) {
            ctx.addIssue('MANY_NOTIFICATIONS', 'Table has ' + notifications.length + ' notifications (' + ctx.metrics.notification_direct_count + ' direct, ' + ctx.metrics.notification_inherited_count + ' inherited). Check for potential spam.', 'medium', {
                record_table: 'sysevent_email_action',
                record_filter: 'collectionIN' + tablesToCheck.join(','),
                category: 'notification'
            });
        }
    },

    /**
     * Check UI Actions for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkUIActions: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var uiActions = [];
        var self = this;
        
        // Get all tables in hierarchy (current table + parent tables)
        var tablesToCheck = self._getTableHierarchy(tableName);
        
        // Query all UI Actions (active and inactive) for complete overview
        // Use GlideRecordSecure to ensure we can read across scopes
        var gr = new GlideRecord('sys_ui_action');
        
        // Build query - check each table individually to avoid IN clause issues
        if (tablesToCheck.length === 1) {
            gr.addQuery('table', tablesToCheck[0]);
        } else {
            var qc = gr.addQuery('table', tablesToCheck[0]);
            for (var i = 1; i < tablesToCheck.length; i++) {
                qc.addOrCondition('table', tablesToCheck[i]);
            }
        }
        gr.query();
        
        while (gr.next()) {
            var actionTable = self._safeGetValue(gr, 'table');
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
            
            uiActions.push({
                sys_id: gr.getUniqueValue(),
                name: self._safeGetValue(gr, 'name') || 'Unnamed',
                action_name: self._safeGetValue(gr, 'action_name'),
                table: actionTable,
                inherited: (actionTable !== tableName),
                active: isActive,
                client: self._safeGetValue(gr, 'client') === 'true',
                form_button: self._safeGetValue(gr, 'form_button') === 'true',
                list_button: self._safeGetValue(gr, 'list_button') === 'true'
            });
        }
        
        ctx.metrics.ui_actions = uiActions;
        ctx.metrics.ui_action_count = uiActions.length;
        ctx.metrics.ui_action_active_count = uiActions.filter(function(a) { return a.active; }).length;
        ctx.metrics.ui_action_inactive_count = uiActions.filter(function(a) { return !a.active; }).length;
        ctx.metrics.ui_action_direct_count = uiActions.filter(function(a) { return !a.inherited; }).length;
        ctx.metrics.ui_action_inherited_count = uiActions.filter(function(a) { return a.inherited; }).length;
        
        // Store tables checked for debugging
        ctx.metrics.ui_action_tables_checked = tablesToCheck;
        
        if (uiActions.length > 25) {
            ctx.addIssue('MANY_UI_ACTIONS', 'Table has ' + uiActions.length + ' UI Actions (' + ctx.metrics.ui_action_active_count + ' active, ' + ctx.metrics.ui_action_direct_count + ' direct). Interface may be overloaded.', 'medium', {
                record_table: 'sys_ui_action',
                record_filter: 'tableIN' + tablesToCheck.join(','),
                category: 'ui'
            });
        }
    },
    
    /**
     * Get table hierarchy (current table + all parent tables)
     * @private
     * @param {String} tableName - Table name
     * @returns {Array} Array of table names
     */
    _getTableHierarchy: function(tableName) {
        var tables = [tableName];
        
        try {
            var tableGr = new GlideRecord('sys_db_object');
            tableGr.addQuery('name', tableName);
            tableGr.query();
            
            if (tableGr.next()) {
                var superClass = tableGr.getValue('super_class');
                while (superClass) {
                    var parentGr = new GlideRecord('sys_db_object');
                    if (parentGr.get(superClass)) {
                        var parentName = parentGr.getValue('name');
                        if (parentName && tables.indexOf(parentName) === -1) {
                            tables.push(parentName);
                        }
                        superClass = parentGr.getValue('super_class');
                    } else {
                        break;
                    }
                }
            }
        } catch(e) {
            // If we can't get hierarchy, just use the table itself
        }
        
        return tables;
    },

    /**
     * Check UI Policies for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkUIPolicies: function(ctx) {
        var tableName = String(ctx.config.table_name);
        var uiPolicies = [];
        var self = this;
        
        // Get all tables in hierarchy (current table + parent tables)
        var tablesToCheck = self._getTableHierarchy(tableName);
        
        var gr = new GlideRecord('sys_ui_policy');
        gr.addQuery('table', 'IN', tablesToCheck.join(','));
        gr.addQuery('active', true);
        gr.query();
        
        while (gr.next()) {
            var policyTable = self._safeGetValue(gr, 'table');
            uiPolicies.push({
                sys_id: gr.getUniqueValue(),
                name: self._safeGetValue(gr, 'short_description') || 'Unnamed',
                table: policyTable,
                inherited: (policyTable !== tableName),
                on_load: self._safeGetValue(gr, 'on_load') === 'true',
                reverse_if_false: self._safeGetValue(gr, 'reverse_if_false') === 'true',
                global: self._safeGetValue(gr, 'global') === 'true'
            });
        }
        
        ctx.metrics.ui_policies = uiPolicies;
        ctx.metrics.ui_policy_count = uiPolicies.length;
        ctx.metrics.ui_policy_direct_count = uiPolicies.filter(function(p) { return !p.inherited; }).length;
        ctx.metrics.ui_policy_inherited_count = uiPolicies.filter(function(p) { return p.inherited; }).length;
        
        if (uiPolicies.length > 15) {
            ctx.addIssue('MANY_UI_POLICIES', 'Table has ' + uiPolicies.length + ' active UI Policies (' + ctx.metrics.ui_policy_direct_count + ' direct, ' + ctx.metrics.ui_policy_inherited_count + ' inherited). This may slow down form loading.', 'medium', {
                record_table: 'sys_ui_policy',
                record_filter: 'tableIN' + tablesToCheck.join(',') + '^active=true',
                category: 'ui'
            });
        }
    },

    type: 'FHCheckAutomation'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-02 23:21:10</sys_created_on>
        <sys_id>7209c240835a321083e1b4a6feaad310</sys_id>
        <sys_mod_count>1</sys_mod_count>
        <sys_name>FHCheckAutomation</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_7209c240835a321083e1b4a6feaad310</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-03 07:51:40</sys_updated_on>
    </sys_script_include>
</record_update>
