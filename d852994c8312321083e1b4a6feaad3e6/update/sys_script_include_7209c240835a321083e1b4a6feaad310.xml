<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHCheckAutomation</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHCheckAutomation</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * FHCheckAutomation - Check for automation issues
 * Analyzes scheduled jobs, flows, workflows, and notifications
 * 
 * Options are managed centrally by FHAnalysisContext:
 * - ctx.isDeepScanEnabled()
 * - ctx.isIncludeChildrenEnabled()
 * - ctx.getTablesToCheck()
 * - ctx.getTableHierarchy()
 */
var FHCheckAutomation = Class.create();
FHCheckAutomation.prototype = {

    /**
     * Execute the check
     * @param {Object} ctx - Analysis context (FHAnalysisContext)
     */
    execute: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        // Register the automation category
        ctx.registerCategory('automation', 'Automation', 'fa-cogs');

        // Get tables to check from context (uses centralized logic)
        var tablesToCheck = ctx.getTablesToCheck();
        ctx.metrics.automation_tables_checked = tablesToCheck;

        this._checkScheduledJobs(ctx, tablesToCheck);
        this._checkFlows(ctx, tablesToCheck);
        this._checkWorkflows(ctx, tablesToCheck);
        this._checkNotifications(ctx, tablesToCheck);
        this._checkUIActions(ctx,tablesToCheck);
        this._checkUIPolicies(ctx,tablesToCheck);
        this._checkInboundEmailActions(ctx, tablesToCheck);

        // Deep scan: analyze automation scripts
        if (ctx.isDeepScanEnabled()) {
            this._deepScanAutomations(ctx);
        }
    },

    /**
     * Check scheduled jobs that reference this table
     * @private
     * @param {Object} ctx - Analysis context
     * @param {Array} configTables - Tables to check
     */
    _checkScheduledJobs: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var scheduledJobs = [];

        // Query all scheduled jobs with scripts that might contain our tables
        var gr = new GlideRecord('sysauto_script');
        gr.addNotNullQuery('script');
        gr.query();

        while (gr.next()) {
            var script = ctx.safeGetValue(gr, 'script');

            // Check if script contains exact reference to any of our tables
            var matchedTable = null;
            for (var i = 0; i < configTables.length; i++) {
                if (ctx.scriptContainsTable(script, configTables[i])) {
                    matchedTable = configTables[i];
                    break;
                }
            }

            if (!matchedTable) continue;

            var jobName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

            scheduledJobs.push({
                sys_id: gr.getUniqueValue(),
                name: jobName,
                active: isActive,
                inherited: matchedTable !== tableName,
                table: 'sysauto_script',
                matched_table: matchedTable,
                run_type: ctx.safeGetValue(gr, 'run_type'),
            });

            if (!isActive) {
                ctx.addIssue('INACTIVE_SCHEDULED_JOB', 'Inactive scheduled job: "' + jobName + '"', 'low', {
                    record_table: 'sysauto_script',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'automation'
                });
            }
        }

        // Add to category for widget consumption
        ctx.addCategoryItems('automation', 'scheduled_job', 'Scheduled Jobs', scheduledJobs, {
            table: 'sysauto_script',
            icon: 'fa-clock',
            color: '#6f42c1'
        });

        // Keep metrics for backward compatibility
        ctx.metrics.scheduled_jobs = scheduledJobs;
        //ctx.metrics.scheduled_job_count = scheduledJobs.length;
    },

    /**
     * Check Flow Designer flows for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     * @param {Array} configTables - Tables from configuration (with children if enabled)
     */
    _checkFlows: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var flows = [];

        try {
            configTables.forEach(function(tableToCheck) {
                var gr = new GlideRecord('sys_hub_flow');

                if (gr.isValid()) {
                    gr.addQuery('label_cache', 'LIKE', configTables);
                    gr.query();

                    while (gr.next()) {
                        var flowName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
                        var flowTable = ctx.safeGetValue(gr, 'trigger_table');
                        var activeVal = gr.getValue('active');
                        var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

                        flows.push({
                            sys_id: gr.getUniqueValue(),
                            name: flowName,
                            table: 'sys_hub_flow',
                            trigger_table: flowTable,
                            inherited: (flowTable !== tableName),
                            active: isActive,
                            trigger_type: ctx.safeGetValue(gr, 'trigger_type'),
                            description: ctx.safeGetValue(gr, 'description')
                        });

                        if (!isActive) {
                            ctx.addIssue('INACTIVE_FLOW', 'Inactive flow: "' + flowName + '"', 'low', {
                                record_table: 'sys_hub_flow',
                                record_sys_id: gr.getUniqueValue(),
                                category: 'automation'
                            });
                        }
                    }
                }
            });

        } catch (e) {
            gs.error('Error checking flows: ' + e.message);
        }

        ctx.addCategoryItems('automation', 'flow', 'Flows', flows, {
            table: 'sys_hub_flow',
            icon: 'fa-project-diagram',
            color: '#17a2b8'
        });

        // // Keep metrics for backward compatibility
        // ctx.metrics.flows = flows;
        ctx.metrics.flow_count = flows.length;
        // ctx.metrics.flow_direct_count = flows.filter(function(f) { return !f.inherited; }).length;
        // ctx.metrics.flow_inherited_count = flows.filter(function(f) { return f.inherited; }).length;

        if (flows.length > 10) {
            ctx.addIssue('MANY_FLOWS', 'Table has ' + flows.length + ' flows. Check for redundancy.', 'medium', {
                record_table: 'sys_hub_flow',
                record_filter: 'trigger_tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * Check legacy workflows for this table
     * @private
     */
    _checkWorkflows: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var workflows = [];

        var gr = new GlideRecord('wf_workflow');
        gr.addQuery('table', 'IN', configTables.join(','));
        gr.query();

        while (gr.next()) {
            var wfName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
            var wfTable = ctx.safeGetValue(gr, 'table');
            var activeVal = gr.getValue('active');
            var publishedVal = gr.getValue('published');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);
            var isPublished = (publishedVal === 'true' || publishedVal === '1' || publishedVal === true);

            workflows.push({
                sys_id: gr.getUniqueValue(),
                name: wfName,
                table: 'wf_workflow',
                trigger_table: wfTable,
                inherited: (wfTable !== tableName),
                active: isActive,
                published: isPublished
            });

            if (isActive && !isPublished) {
                ctx.addIssue('UNPUBLISHED_WORKFLOW', 'Active but unpublished workflow: "' + wfName + '"', 'medium', {
                    record_table: 'wf_workflow',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'automation'
                });
            }
        }

        // Add to category
        ctx.addCategoryItems('automation', 'workflow', 'Workflows', workflows, {
            table: 'wf_workflow',
            icon: 'fa-sitemap',
            color: '#fd7e14'
        });

         //ctx.metrics.workflows = workflows;
        ctx.metrics.workflow_count = workflows.length;
        // ctx.metrics.workflow_direct_count = workflows.filter(function(w) {
        //     return !w.inherited;
        // }).length;
        // ctx.metrics.workflow_inherited_count = workflows.filter(function(w) {
        //     return w.inherited;
        // }).length;

        if (workflows.length > 0) {
            ctx.addIssue('LEGACY_WORKFLOWS', 'Table uses ' + workflows.length + ' legacy workflow(s). Consider migrating to Flow Designer.', 'low', {
                record_table: 'wf_workflow',
                record_filter: 'tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * Check notifications for this table
     * @private
     */
    _checkNotifications: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var notifications = [];

        var gr = new GlideRecord('sysevent_email_action');
        gr.addQuery('collection', 'IN', configTables.join(','));
        gr.query();

        while (gr.next()) {
            var notifTable = ctx.safeGetValue(gr, 'collection');
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

            notifications.push({
                sys_id: gr.getUniqueValue(),
                name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                table: 'sysevent_email_action',
                trigger_table: notifTable,
                inherited: (notifTable !== tableName),
                active: isActive,
                event_name: ctx.safeGetValue(gr, 'event_name'),
                send_self: ctx.safeGetValue(gr, 'send_self') === 'true'
            });
        }

        // Add to category
        ctx.addCategoryItems('automation', 'notification', 'Notifications', notifications, {
            table: 'sysevent_email_action',
            icon: 'fa-envelope',
            color: '#28a745'
        });

        // ctx.metrics.notifications = notifications;
         ctx.metrics.notification_count = notifications.length;
        // ctx.metrics.notification_direct_count = notifications.filter(function(n) {
        //     return !n.inherited;
        // }).length;
        // ctx.metrics.notification_inherited_count = notifications.filter(function(n) {
        //     return n.inherited;
        // }).length;

        if (notifications.length > 20) {
            ctx.addIssue('MANY_NOTIFICATIONS', 'Table has ' + notifications.length + ' notifications. Check for potential spam.', 'medium', {
                record_table: 'sysevent_email_action',
                record_filter: 'collectionIN' + configTables.join(','),
                category: 'notification'
            });
        }
    },

    /**
     * Check UI Actions for this table (including inherited from parent tables)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkUIActions: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var uiActions = [];

        var gr = new GlideRecord('sys_ui_action');
        gr.addQuery('table', 'IN', configTables.join(','));
        gr.query();

        while (gr.next()) {
            var actionTable = ctx.safeGetValue(gr, 'table');
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

            uiActions.push({
                sys_id: gr.getUniqueValue(),
                name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                action_name: ctx.safeGetValue(gr, 'action_name'),
                table: 'sys_ui_action',
                trigger_table: actionTable,
                inherited: (actionTable !== tableName),
                active: isActive,
            });
        }

        // Add to category
        ctx.addCategoryItems('automation', 'ui_action', 'UI Actions', uiActions, {
            table: 'sys_ui_action',
            icon: 'fa-mouse-pointer',
            color: '#dc3545'
        });

        // ctx.metrics.ui_actions = uiActions;
         ctx.metrics.ui_action_count = uiActions.length;
        // ctx.metrics.ui_action_active_count = uiActions.filter(function(a) {
        //     return a.active;
        // }).length;
        // ctx.metrics.ui_action_inactive_count = uiActions.filter(function(a) {
        //     return !a.active;
        // }).length;
        // ctx.metrics.ui_action_direct_count = uiActions.filter(function(a) {
        //     return !a.inherited;
        // }).length;
        // ctx.metrics.ui_action_inherited_count = uiActions.filter(function(a) {
        //     return a.inherited;
        // }).length;
        // ctx.metrics.ui_action_tables_checked = tablesToCheck;

        if (uiActions.length > 25) {
            ctx.addIssue('MANY_UI_ACTIONS', 'Table has ' + uiActions.length + ' UI Actions. Interface may be overloaded.', 'medium', {
                record_table: 'sys_ui_action',
                record_filter: 'tableIN' + configTables.join(','),
                category: 'ui'
            });
        }
    },

    /**
     * Check UI Policies for this table
     * @private
     */
    _checkUIPolicies: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var uiPolicies = [];

        var gr = new GlideRecord('sys_ui_policy');
        gr.addQuery('table', 'IN', configTables.join(','));
        gr.query();

        while (gr.next()) {
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

            var policyTable = ctx.safeGetValue(gr, 'table');
            uiPolicies.push({
                sys_id: gr.getUniqueValue(),
                name: ctx.safeGetValue(gr, 'short_description') || 'Unnamed',
                table: 'sys_ui_policy',
                trigger_table: policyTable,
                inherited: (policyTable !== tableName),
                active: isActive,
                on_load: ctx.safeGetValue(gr, 'on_load') === 'true',
                reverse_if_false: ctx.safeGetValue(gr, 'reverse_if_false') === 'true',
                global: ctx.safeGetValue(gr, 'global') === 'true'
            });
        }

        // Add to category
        ctx.addCategoryItems('automation', 'ui_policy', 'UI Policies', uiPolicies, {
            table: 'sys_ui_policy',
            icon: 'fa-shield-alt',
            color: '#20c997'
        });

        // ctx.metrics.ui_policies = uiPolicies;
         ctx.metrics.ui_policy_count = uiPolicies.length;
        // ctx.metrics.ui_policy_direct_count = uiPolicies.filter(function(p) {
        //     return !p.inherited;
        // }).length;
        // ctx.metrics.ui_policy_inherited_count = uiPolicies.filter(function(p) {
        //     return p.inherited;
        // }).length;

        if (uiPolicies.length > 15) {
            ctx.addIssue('MANY_UI_POLICIES', 'Table has ' + uiPolicies.length + ' active UI Policies. This may slow down form loading.', 'medium', {
                record_table: 'sys_ui_policy',
                record_filter: 'tableIN' + configTables.join(',') + '^active=true',
                category: 'ui'
            });
        }
    },

    /**
     * Check inbound email actions for this table
     * @private
     */
    _checkInboundEmailActions: function(ctx, configTables) {
        var tableName = ctx.getTableName();
        var inboundEmails = [];

        // Check sysevent_in_email_action (Inbound Email Actions)
        try {
            var gr = new GlideRecord('sysevent_in_email_action');
            if (gr.isValid()) {
                gr.addQuery('table', 'IN', configTables.join(','));
                gr.query();

                while (gr.next()) {
                    var emailTable = ctx.safeGetValue(gr, 'table');
                    var activeVal = gr.getValue('active');
                    var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

                    inboundEmails.push({
                        sys_id: gr.getUniqueValue(),
                        name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                        table: 'sysevent_in_email_action',
                        trigger_table: emailTable,
                        inherited: (emailTable !== tableName),
                        active: isActive,
                        type: ctx.safeGetValue(gr, 'type'),
                        action_type: ctx.safeGetValue(gr, 'action_type'),
                        stop_processing: ctx.safeGetValue(gr, 'stop_processing') === 'true'
                    });

                    if (!isActive) {
                        ctx.addIssue('INACTIVE_INBOUND_EMAIL', 'Inactive inbound email action: "' + inboundEmails[inboundEmails.length - 1].name + '"', 'low', {
                            record_table: 'sysevent_in_email_action',
                            record_sys_id: gr.getUniqueValue(),
                            category: 'automation'
                        });
                    }
                }
            }
        } catch (e) {
            // Table might not be accessible
        }

        // Check sys_hub_trigger_instance (Flow Triggers including email)
        try {
            configTables.forEach(function(tableToCheck) {
                var triggerGr = new GlideRecord('sys_hub_trigger_instance');
                if (triggerGr.isValid()) {
                    triggerGr.addQuery('trigger_type', 'IS', 'email');
                    triggerGr.addQuery('flow.label_cache', 'LIKE', tableToCheck);
                    triggerGr.query();

                    while (triggerGr.next()) {
                        var triggerConfig = ctx.safeGetValue(triggerGr, 'trigger_config');
                        var isRelated = false;

                        configTables.forEach(function(t) {
                            if (triggerConfig && triggerConfig.indexOf(t) > -1) {
                                isRelated = true;
                            }
                        });

                        if (isRelated) {
                            var flowRef = triggerGr.flow;
                            var flowName = '';
                            if (flowRef && !flowRef.nil()) {
                                var flowGr = flowRef.getRefRecord();
                                if (flowGr) {
                                    flowName = ctx.safeGetValue(flowGr, 'name');
                                }
                            }

                            inboundEmails.push({
                                sys_id: triggerGr.getUniqueValue(),
                                name: flowName || 'Flow Trigger',
                                table: 'sys_hub_trigger_instance',
                                trigger_table: tableName,
                                inherited: false,
                                active: true,
                                type: 'flow_trigger',
                                action_type: 'email',
                                stop_processing: false
                            });
                        }
                    }

                }
            });
        } catch (e) {
            // Table might not exist
        }

        // Add to category
        ctx.addCategoryItems('automation', 'inbound_email', 'Inbound Email Actions', inboundEmails, {
            table: 'sysevent_in_email_action',
            icon: 'fa-inbox',
            color: '#e83e8c'
        });

        // ctx.metrics.inbound_email_actions = inboundEmails;
         ctx.metrics.inbound_email_count = inboundEmails.length;
        // ctx.metrics.inbound_email_active_count = inboundEmails.filter(function(e) {
        //     return e.active;
        // }).length;
        // ctx.metrics.inbound_email_direct_count = inboundEmails.filter(function(e) {
        //     return !e.inherited;
        // }).length;

        if (inboundEmails.length > 10) {
            ctx.addIssue('MANY_INBOUND_EMAILS', 'Table has ' + inboundEmails.length + ' inbound email actions. Review for efficiency.', 'low', {
                record_table: 'sysevent_in_email_action',
                record_filter: 'target_tableIN' + configTables.join(','),
                category: 'automation'
            });
        }
    },

    /**
     * Deep scan automations for script quality (if deep_scan option is enabled)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _deepScanAutomations: function(ctx) {
        var automationIssues = [];
        var self = this;

        // Scan Flows for complexity
        if (ctx.metrics.flows && ctx.metrics.flows.length > 0) {
            ctx.metrics.flows.forEach(function(flow) {
                if (flow.active) {
                    // Check for flows without description
                    if (!flow.description) {
                        automationIssues.push({
                            type: 'Flow',
                            name: flow.name,
                            code: 'NO_DESCRIPTION',
                            message: 'Flow "' + flow.name + '" has no description',
                            severity: 'low'
                        });
                    }
                }
            });
        }

        // Scan Scheduled Jobs for script issues
        if (ctx.metrics.scheduled_jobs && ctx.metrics.scheduled_jobs.length > 0) {
            var jobGr = new GlideRecord('sysauto_script');
            ctx.metrics.scheduled_jobs.forEach(function(job) {
                if (jobGr.get(job.sys_id)) {
                    var script = ctx.safeGetValue(jobGr, 'script');
                    var issues = self._analyzeAutomationScript(script, job.name, 'Scheduled Job');
                    automationIssues = automationIssues.concat(issues);
                }
            });
        }

        // ctx.metrics.automation_script_issues = automationIssues;
         ctx.metrics.automation_script_issue_count = automationIssues.length;

        // Add issues
        automationIssues.forEach(function(issue) {
            ctx.addIssue(issue.code, issue.message, issue.severity, {
                category: 'automation'
            });
        });
    },

    /**
     * Analyze automation script for common issues
     * @private
     */
    _analyzeAutomationScript: function(script, scriptName, scriptType) {
        var issues = [];
        if (!script) return issues;

        // Check for GlideRecord in loop without limit
        if (script.indexOf('GlideRecord') > -1 && script.indexOf('.query()') > -1) {
            if (script.indexOf('setLimit') === -1 && script.indexOf('get(') === -1) {
                if (script.indexOf('while') > -1 && script.indexOf('.next()') > -1) {
                    issues.push({
                        type: scriptType,
                        name: scriptName,
                        code: 'QUERY_NO_LIMIT',
                        message: scriptType + ' "' + scriptName + '" has GlideRecord query without setLimit()',
                        severity: 'medium'
                    });
                }
            }
        }

        // Check for hardcoded sys_ids (32 hex characters)
        var sysIdPattern = /['"]\s*[a-fA-F0-9]{32}\s*['"]/g;
        var sysIdMatches = script.match(sysIdPattern);
        if (sysIdMatches && sysIdMatches.length > 0) {
            issues.push({
                type: scriptType,
                name: scriptName,
                code: 'HARDCODED_SYSID',
                message: scriptType + ' "' + scriptName + '" contains ' + sysIdMatches.length + ' hardcoded sys_id value(s)',
                severity: 'medium'
            });
        }

        // Check for gs.sleep (can cause performance issues)
        if (script.indexOf('gs.sleep') > -1) {
            issues.push({
                type: scriptType,
                name: scriptName,
                code: 'GS_SLEEP',
                message: scriptType + ' "' + scriptName + '" uses gs.sleep() which can impact performance',
                severity: 'medium'
            });
        }

        // Check for eval usage
        if (script.indexOf('eval(') > -1) {
            issues.push({
                type: scriptType,
                name: scriptName,
                code: 'EVAL_USAGE',
                message: scriptType + ' "' + scriptName + '" uses eval() which is a security risk',
                severity: 'high'
            });
        }

        return issues;
    },

    type: 'FHCheckAutomation'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-02 23:21:10</sys_created_on>
        <sys_id>7209c240835a321083e1b4a6feaad310</sys_id>
        <sys_mod_count>13</sys_mod_count>
        <sys_name>FHCheckAutomation</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_7209c240835a321083e1b4a6feaad310</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-04 06:48:33</sys_updated_on>
    </sys_script_include>
</record_update>
