<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHCheckTable</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHCheckTable</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var FHCheckTable = Class.create();
FHCheckTable.prototype = {
    initialize: function() {
        this.utils = new FHScanUtils();
        this.optionsHandler = new FHOptionsHandler();
    },

    /**
     * execute(ctx)
     * Public entrypoint retained for compatibility.
     * ctx is the FHAnalysisContext instance used across the analyzer.
     */
    execute: function(ctx) {
        // _checkTableSummary doit être appelé en tout premier car il expose ctx.metrics.table (namespace)
        this._checkTableSummary(ctx);

        // Ensuite les autres checks peuvent s'appuyer sur ctx.metrics.table.exists / record_count
        this._checkFieldUsage(ctx);
        this._checkReferenceFields(ctx);
        this._checkBusinessRules(ctx);
        this._checkClientScripts(ctx);

        if (ctx.isDeepScanEnabled && ctx.isDeepScanEnabled()) {
            this.optionsHandler.deepScanTransformMaps(ctx);
        }

        if (ctx.isAnalyzeReferencesEnabled && ctx.isAnalyzeReferencesEnabled()) {
            this.optionsHandler.analyzeIntegrationDependencies(ctx);
        }

        if (ctx.isLdapEnabled && ctx.isLdapEnabled()) {
            this.optionsHandler.analyzeLdapConfiguration(ctx);
        }
    },

    /**
     * Check table existence + record count, raise issues,
     * and add a "Table Summary" item in the 'table' category for UI.
     * THIS function uses addCategoryAndMetrics as unique writer of metrics.
     */
    _checkTableSummary: function(ctx) {
        ctx.metrics = ctx.metrics || {};
        // We'll store metrics under ctx.metrics.table namespace
        var metricNs = 'table';
        ctx.metrics[metricNs] = ctx.metrics[metricNs] || {};

        var tableName = (ctx.getTableName && ctx.getTableName()) || (ctx.config && ctx.config.table_name);
        var tableLabel = null;
        var recordCount = 0;
        var exists = false;

        if (!tableName) {
            ctx.addIssue('INVALID_CONFIG', 'Table name is not defined in configuration', 'high');
            // create missing summary object
            var missingSummary = {
                table: null,
                label: null,
                exists: false,
                record_count: 0
            };

            // call helper to add category/UI and write metrics
            var meta = {};
            try {
                if (this.utils && typeof this.utils.addCategoryAndMetrics === 'function') {
                    meta = this.utils.addCategoryAndMetrics(ctx, 'table', 'table_summary', 'Table Summary', [missingSummary], {
                        table: 'sys_db_object',
                        icon: 'fa-table',
                        color: '#d9534f',
                        metricNamespace: metricNs,
                        countKeys: {
                            total: 'table_summary_count'
                        },
                        writeConvenienceKeys: true
                    });
                } else if (ctx.addCategoryItems) {
                    ctx.addCategoryItems('table', 'table_summary', 'Table Summary', [missingSummary], {
                        table: 'sys_db_object',
                        icon: 'fa-table'
                    });
                    ctx.metrics[metricNs].exists = false;
                    ctx.metrics[metricNs].record_count = 0;
                    meta.success = true;
                }
            } catch (e) {
                gs.error('FHCheckTable._checkTableSummary (missing) addCategory error: ' + e);
                ctx.metrics[metricNs].exists = false;
                ctx.metrics[metricNs].record_count = 0;
            }
            return; // nothing else to do
        }

        // Query sys_db_object to verify existence and get label (if any)
        try {
            var gr = new GlideRecord('sys_db_object');
            if (gr.get('name', tableName)) {
                exists = true;
                // prefer user-friendly label if available
                tableLabel = gr.getValue('label') || gr.getValue('name');
            } else {
                exists = false;
                ctx.addIssue('TABLE_NOT_FOUND', 'Table "' + tableName + '" does not exist in the system', 'high');
            }
        } catch (e) {
            gs.error('FHCheckTable._checkTableSummary error checking sys_db_object: ' + e);
            // fallback: treat as not existing
            exists = false;
        }

        // If table exists, attempt a lightweight record count (use GlideAggregate for performance)
        if (exists) {
            try {
                var ga = new GlideAggregate(tableName);
                ga.addAggregate('COUNT');
                ga.query();
                if (ga.next()) {
                    recordCount = parseInt(ga.getAggregate('COUNT'), 10) || 0;
                } else {
                    recordCount = 0;
                }
            } catch (e) {
                gs.error('FHCheckTable._checkTableSummary record count error for ' + tableName + ': ' + e);
                recordCount = 0;
            }

            // Raise issues based on record count
            if (recordCount === 0) {
                ctx.addIssue('EMPTY_TABLE', 'Table "' + tableName + '" contains no records.', 'low', {
                    record_table: tableName
                });
            } else if (recordCount > 100000) { // seuil configurable si besoin
                ctx.addIssue('LARGE_TABLE', 'Table "' + tableName + '" has ' + recordCount + ' records — consider archiving.', 'medium', {
                    record_table: tableName
                });
            }
        }

        // Build summary object and hand to helper which will write metrics under ctx.metrics.table.*
        var tableSummary = {
            table: tableName,
            label: tableLabel || tableName,
            exists: !!exists,
            record_count: recordCount
        };

        try {
            if (this.utils && typeof this.utils.addCategoryAndMetrics === 'function') {
                var meta = this.utils.addCategoryAndMetrics(ctx, 'table', 'table_summary', 'Table Summary', [tableSummary], {
                    table: 'sys_db_object',
                    icon: 'fa-table',
                    color: exists ? '#17a2b8' : '#d9534f',
                    metricNamespace: metricNs,
                    countKeys: {
                        total: 'table_summary_count'
                    },
                    writeConvenienceKeys: true
                });
                // meta contient les clés écrites si besoin
            } else if (ctx.addCategoryItems) {
                ctx.addCategoryItems('table', 'table_summary', 'Table Summary', [tableSummary], {
                    table: 'sys_db_object',
                    icon: 'fa-table'
                });
                // fallback: write minimal metrics so subsequent checks can run
                ctx.metrics[metricNs].table_summary_count = 1;
                ctx.metrics[metricNs].exists = !!exists;
                ctx.metrics[metricNs].record_count = recordCount;
            }
        } catch (e) {
            gs.error('FHCheckTable._checkTableSummary addCategory error: ' + e);
            // ensure fallback metrics exist
            ctx.metrics[metricNs].exists = !!exists;
            ctx.metrics[metricNs].record_count = recordCount;
        }
    },

    /**
     * Example: Check field usage (starts only if table exists)
     * (I leave implementations minimal — tu as déjà les versions précédentes)
     */
    _checkFieldUsage: function(ctx) {
        var metricNs = 'table';
        if (!ctx.metrics || !ctx.metrics[metricNs] || !ctx.metrics[metricNs].exists) return;

        var tableName = (ctx.getTableName && ctx.getTableName()) || (ctx.config && ctx.config.table_name);
        // Implémentation de ta logique de vérification des champs...
        // Exemple minimal (remplacer par ton code complet)
        // ...
    },

    _checkReferenceFields: function(ctx) {
        var metricNs = 'table';
        if (!ctx.metrics || !ctx.metrics[metricNs] || !ctx.metrics[metricNs].exists) return;
        // Implémentation...
    },

    _checkBusinessRules: function(ctx) {
        var metricNs = 'table';
        if (!ctx.metrics || !ctx.metrics[metricNs] || !ctx.metrics[metricNs].exists) return;

        var tableName = (ctx.getTableName && ctx.getTableName()) || (ctx.config && ctx.config.table_name);

        // Example: count active/inactive business rules for the table
        try {
            var activeBR = 0,
                inactiveBR = 0;
            var gr = new GlideRecord('sys_script');
            gr.addQuery('collection', tableName);
            gr.query();
            while (gr.next()) {
                if (gr.getValue('active') === 'true' || gr.getValue('active') === true) activeBR++;
                else inactiveBR++;
            }

            // Create list items to show in UI (optional)
            var brSummary = [{
                    key: tableName + ':active_business_rules',
                    name: 'Active Business Rules',
                    count: activeBR
                },
                {
                    key: tableName + ':inactive_business_rules',
                    name: 'Inactive Business Rules',
                    count: inactiveBR
                }
            ];

            // Use helper to write metrics under ctx.metrics.table.*
            if (this.utils && typeof this.utils.addCategoryAndMetrics === 'function') {
                // Add as separate category items (category 'business_rule'), helper will create metrics under metricNamespace 'business_rule' by default
                this.utils.addCategoryAndMetrics(ctx, 'business_rule', 'business_rule_summary', 'Business Rules', brSummary, {
                    table: 'sys_script',
                    icon: 'fa-cog',
                    metricNamespace: 'business_rule',
                    countKeys: {
                        total: 'business_rule_count',
                        active: 'business_rule_active_count',
                        inactive: 'business_rule_inactive_count'
                    }
                });
            } else {
                // fallback minimal metrics
                ctx.metrics.business_rule = ctx.metrics.business_rule || {};
                ctx.metrics.business_rule.business_rule_count = activeBR + inactiveBR;
                ctx.metrics.business_rule.business_rule_active_count = activeBR;
                ctx.metrics.business_rule.business_rule_inactive_count = inactiveBR;
            }

            if (activeBR > 50) {
                ctx.addIssue('MANY_BUSINESS_RULES', 'Table has ' + (activeBR + inactiveBR) + ' business rules, ' + activeBR + ' active. This may impact performance.', 'medium', {
                    record_table: 'sys_script',
                    record_filter: 'collection=' + tableName + '^active=true',
                    category: 'business_rule'
                });
            }

            if (inactiveBR > 10) {
                ctx.addIssue('INACTIVE_BUSINESS_RULES', 'Table has ' + inactiveBR + ' inactive business rules. Consider removing them.', 'low', {
                    record_table: 'sys_script',
                    record_filter: 'collection=' + tableName + '^active=false',
                    category: 'business_rule'
                });
            }
        } catch (e) {
            gs.error('FHCheckTable._checkBusinessRules error: ' + e);
        }
    },

    _checkClientScripts: function(ctx) {
        var metricNs = 'table';
        if (!ctx.metrics || !ctx.metrics[metricNs] || !ctx.metrics[metricNs].exists) return;

        var tableName = (ctx.getTableName && ctx.getTableName()) || (ctx.config && ctx.config.table_name);

        var clientScripts = [];
        try {
            var gr = new GlideRecord('sys_script_client');
            gr.addQuery('table', tableName);
            gr.addQuery('active', true);
            gr.query();
            while (gr.next()) {
                clientScripts.push({
                    name: ctx.safeGetValue ? ctx.safeGetValue(gr, 'name') || 'Unnamed' : gr.getValue('name') || 'Unnamed',
                    type: ctx.safeGetValue ? ctx.safeGetValue(gr, 'type') : gr.getValue('type'),
                    ui_type: ctx.safeGetValue ? ctx.safeGetValue(gr, 'ui_type') : gr.getValue('ui_type')
                });
            }
        } catch (e) {
            gs.error('FHCheckTable._checkClientScripts query error: ' + e);
        }

        try {
            if (this.utils && typeof this.utils.addCategoryAndMetrics === 'function') {
                this.utils.addCategoryAndMetrics(ctx, 'table', 'client_scripts', 'Client Scripts', clientScripts, {
                    table: 'sys_script_client',
                    icon: 'fa-desktop',
                    metricNamespace: 'table', // on veut que ces compteurs soient accessibles sous ctx.metrics.table.*
                    countKeys: {
                        total: 'client_script_count'
                    }
                });
            } else if (ctx.addCategoryItems) {
                ctx.addCategoryItems('table', 'client_scripts', 'Client Scripts', clientScripts, {
                    table: 'sys_script_client',
                    icon: 'fa-desktop'
                });
                ctx.metrics.table.client_script_count = clientScripts.length;
            }
        } catch (e) {
            gs.error('FHCheckTable._checkClientScripts addCategory error: ' + e);
            ctx.metrics.table.client_script_count = clientScripts.length;
        }

        if (clientScripts.length > 15) {
            ctx.addIssue('MANY_CLIENT_SCRIPTS', 'Table has ' + clientScripts.length + ' active client scripts. This may impact user experience.', 'medium', {
                record_table: 'sys_script_client',
                record_filter: 'table=' + tableName + '^active=true',
                category: 'client_script'
            });
        }
    },

    type: 'FHCheckTable'

};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-02 23:20:59</sys_created_on>
        <sys_id>99f80240835a321083e1b4a6feaad361</sys_id>
        <sys_mod_count>19</sys_mod_count>
        <sys_name>FHCheckTable</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_99f80240835a321083e1b4a6feaad361</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-04 21:27:07</sys_updated_on>
    </sys_script_include>
</record_update>
