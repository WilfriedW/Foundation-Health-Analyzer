<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHCheckTable</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHCheckTable</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * FHCheckTable - Check for table-specific issues
 * Analyzes custom fields, reference fields, and business rules
 * 
 * Options are managed centrally by FHAnalysisContext:
 * - ctx.isDeepScanEnabled()
 * - ctx.isIncludeChildrenEnabled()
 * - ctx.isAnalyzeReferencesEnabled()
 * - ctx.getTableHierarchy()
 * - ctx.getTablesToCheck()
 */
var FHCheckTable = Class.create();
FHCheckTable.prototype = {

    /**
     * Execute the check
     * @param {Object} ctx - Analysis context (FHAnalysisContext)
     */
    execute: function(ctx) {
        // Run standard checks
        this._checkTableExists(ctx);
        this._checkRecordCount(ctx);
        this._checkFieldUsage(ctx);
        this._checkReferenceFields(ctx);
        this._checkBusinessRules(ctx);
        this._checkClientScripts(ctx);

        // Include children tables analysis if option is enabled
        if (ctx.isIncludeChildrenEnabled()) {
            this._checkChildrenTables(ctx);
        }

        // Analyze reference field data quality if option is enabled
        if (ctx.isAnalyzeReferencesEnabled()) {
            this._analyzeReferenceData(ctx);
        }

        // Deep scan: analyze script quality if option is enabled
        if (ctx.isDeepScanEnabled()) {
            this._deepScanScripts(ctx);
        }
    },

    /**
     * Check if table exists
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkTableExists: function(ctx) {
        var tableName = ctx.getTableName();

        if (!tableName) {
            ctx.addIssue('INVALID_CONFIG', 'Table name is not defined in configuration', 'high');
            ctx.metrics.table_exists = false;
            return;
        }

        var gr = new GlideRecord('sys_db_object');
        if (!gr.get('name', tableName)) {
            ctx.addIssue('TABLE_NOT_FOUND', 'Table "' + tableName + '" does not exist in the system', 'high');
            ctx.metrics.table_exists = false;
            return;
        }
        ctx.metrics.table_exists = true;
        ctx.metrics.table_label = ctx.safeGetValue(gr, 'label') || tableName;
    },

    /**
     * Check record count
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkRecordCount: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = String(ctx.config.table_name);
        var ga = new GlideAggregate(tableName);
        ga.addAggregate('COUNT');
        ga.query();

        var count = 0;
        if (ga.next()) {
            count = parseInt(ga.getAggregate('COUNT'), 10) || 0;
        }

        ctx.metrics.record_count = count;

        if (count === 0) {
            ctx.addIssue('EMPTY_TABLE', 'Table contains no records', 'medium');
        } else if (count > 1000000) {
            ctx.addIssue('LARGE_TABLE', 'Table contains more than one million records (' + count + '). Consider archiving.', 'medium');
        }
    },

    /**
     * Check field usage - analyzes custom fields and their fill rates
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkFieldUsage: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = String(ctx.config.table_name);
        var customFields = [];
        var unusedFields = [];
        var lowUsageFields = [];
        var self = this;

        // Get all custom fields (u_ prefix or from scoped app)
        var gr = new GlideRecord('sys_dictionary');
        gr.addQuery('name', tableName);
        gr.addQuery('element', 'STARTSWITH', 'u_');
        gr.addQuery('internal_type', '!=', 'collection');
        gr.orderBy('element');
        gr.query();

        while (gr.next()) {
            var fieldName = ctx.safeGetValue(gr, 'element');
            if (!fieldName) continue;

            var fieldLabel = ctx.safeGetValue(gr, 'column_label') || fieldName;
            var fieldType = ctx.safeGetValue(gr, 'internal_type') || 'unknown';

            // Calculate fill rate
            var fillRate = this._calculateFillRate(tableName, fieldName, ctx.metrics.record_count);

            var fieldInfo = {
                name: fieldName,
                label: fieldLabel,
                type: fieldType,
                fill_rate: fillRate,
                mandatory: ctx.safeGetValue(gr, 'mandatory') === 'true'
            };

            customFields.push(fieldInfo);

            // Check for issues
            if (fillRate === 0) {
                unusedFields.push(fieldName);
                ctx.addIssue('UNUSED_FIELD', 'Field "' + fieldLabel + '" (' + fieldName + ') is never populated (0%)', 'high', {
                    record_table: 'sys_dictionary',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'field'
                });
            } else if (fillRate < 10) {
                lowUsageFields.push(fieldName);
                ctx.addIssue('LOW_USAGE_FIELD', 'Field "' + fieldLabel + '" (' + fieldName + ') has low usage (' + fillRate + '%)', 'medium', {
                    record_table: 'sys_dictionary',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'field'
                });
            }

            // Check for potential OOTB duplicates
            if (fieldName.length > 2) {
                var baseName = fieldName.substring(2); // Remove u_ prefix
                if (this._ootbFieldExists(tableName, baseName)) {
                    ctx.addIssue('POTENTIAL_DUPLICATE', 'Field "' + fieldName + '" might be a duplicate of OOTB field "' + baseName + '"', 'medium', {
                        record_table: 'sys_dictionary',
                        record_sys_id: gr.getUniqueValue(),
                        category: 'field'
                    });
                }
            }
        }

        ctx.metrics.custom_fields = customFields;
        ctx.metrics.custom_field_count = customFields.length;
        ctx.metrics.unused_field_count = unusedFields.length;
        ctx.metrics.low_usage_field_count = lowUsageFields.length;

        if (customFields.length > 50) {
            ctx.addIssue('TOO_MANY_CUSTOM_FIELDS', 'Table has ' + customFields.length + ' custom fields. Consider consolidation.', 'medium');
        }

    },

    /**
     * Analyze which scripts update custom fields
     * @private
     * @param {Object} ctx - Analysis context
     * @param {Array} customFields - List of custom fields
     */
    _analyzeFieldUpdaters: function(ctx, customFields) {
        var tableName = ctx.getTableName();
        var fieldUpdaters = {};

        // Initialize field updaters map
        customFields.forEach(function(field) {
            fieldUpdaters[field.name] = {
                field_name: field.name,
                field_label: field.label,
                updated_by: []
            };
        });

        // Check Business Rules
        var brGr = new GlideRecord('sys_script');
        brGr.addQuery('collection', tableName);
        brGr.addQuery('active', true);
        brGr.query();

        while (brGr.next()) {
            var brScript = ctx.safeGetValue(brGr, 'script');
            var brName = ctx.safeGetValue(brGr, 'name') || 'Unnamed';
            var brSysId = brGr.getUniqueValue();

            customFields.forEach(function(field) {
                if (ctx.scriptUpdatesField(brScript, field.name)) {
                    fieldUpdaters[field.name].updated_by.push({
                        type: 'Business Rule',
                        name: brName,
                        sys_id: brSysId,
                        table: 'sys_script'
                    });
                }
            });
        }

        // Check Scheduled Jobs
        var jobGr = new GlideRecord('sysauto_script');
        jobGr.addQuery('active', true);
        jobGr.query();

        while (jobGr.next()) {
            var jobScript = ctx.safeGetValue(jobGr, 'script');
            var jobName = ctx.safeGetValue(jobGr, 'name') || 'Unnamed';
            var jobSysId = jobGr.getUniqueValue();

            // Check if job references our table AND updates our fields
            if (ctx.scriptContainsTable(jobScript, tableName)) {
                customFields.forEach(function(field) {
                    if (ctx.scriptUpdatesField(jobScript, field.name)) {
                        fieldUpdaters[field.name].updated_by.push({
                            type: 'Scheduled Job',
                            name: jobName,
                            sys_id: jobSysId,
                            table: 'sysauto_script'
                        });
                    }
                });
            }
        }

        // Check Flows (script actions)
        try {
            var flowGr = new GlideRecord('sys_hub_flow');
            if (flowGr.isValid()) {
                flowGr.addQuery('trigger_table', tableName);
                flowGr.addQuery('active', true);
                flowGr.query();

                while (flowGr.next()) {
                    var flowName = ctx.safeGetValue(flowGr, 'name') || 'Unnamed';
                    var flowSysId = flowGr.getUniqueValue();

                    // Check flow actions for field updates
                    var actionGr = new GlideRecord('sys_hub_action_instance');
                    actionGr.addQuery('flow', flowSysId);
                    actionGr.query();

                    while (actionGr.next()) {
                        var actionInputs = ctx.safeGetValue(actionGr, 'inputs');
                        customFields.forEach(function(field) {
                            if (actionInputs && actionInputs.indexOf(field.name) > -1) {
                                // Check if not already added
                                var alreadyAdded = fieldUpdaters[field.name].updated_by.some(function(u) {
                                    return u.type === 'Flow' && u.sys_id === flowSysId;
                                });
                                if (!alreadyAdded) {
                                    fieldUpdaters[field.name].updated_by.push({
                                        type: 'Flow',
                                        name: flowName,
                                        sys_id: flowSysId,
                                        table: 'sys_hub_flow'
                                    });
                                }
                            }
                        });
                    }
                }
            }
        } catch (e) {
            // Flow Designer might not exist
        }

        // Check Transform Maps
        var tmGr = new GlideRecord('sys_transform_map');
        tmGr.addQuery('target_table', tableName);
        tmGr.addQuery('active', true);
        tmGr.query();

        while (tmGr.next()) {
            var tmName = ctx.safeGetValue(tmGr, 'name') || 'Unnamed';
            var tmSysId = tmGr.getUniqueValue();

            // Check field maps
            var fmGr = new GlideRecord('sys_transform_entry');
            fmGr.addQuery('map', tmSysId);
            fmGr.query();

            while (fmGr.next()) {
                var targetField = ctx.safeGetValue(fmGr, 'target_field');
                if (fieldUpdaters[targetField]) {
                    fieldUpdaters[targetField].updated_by.push({
                        type: 'Transform Map',
                        name: tmName,
                        sys_id: tmSysId,
                        table: 'sys_transform_map'
                    });
                }
            }
        }

        // Update custom fields with updater info
        ctx.metrics.custom_fields = ctx.metrics.custom_fields.map(function(field) {
            field.updated_by = fieldUpdaters[field.name] ? fieldUpdaters[field.name].updated_by : [];
            return field;
        });

        // Store summary
        ctx.metrics.field_updaters = fieldUpdaters;
    },

    /**
     * Calculate fill rate for a field
     * @private
     */
    _calculateFillRate: function(tableName, fieldName, totalRecords) {
        if (!totalRecords || totalRecords === 0) return 0;

        try {
            var ga = new GlideAggregate(tableName);
            ga.addNotNullQuery(fieldName);
            ga.addQuery(fieldName, '!=', '');
            ga.addAggregate('COUNT');
            ga.query();

            var filledCount = 0;
            if (ga.next()) {
                filledCount = parseInt(ga.getAggregate('COUNT'), 10) || 0;
            }

            return Math.round((filledCount / totalRecords) * 100);
        } catch (e) {
            return 0;
        }
    },

    /**
     * Check if OOTB field exists
     * @private
     */
    _ootbFieldExists: function(tableName, fieldName) {
        if (!fieldName) return false;

        var gr = new GlideRecord('sys_dictionary');
        gr.addQuery('name', tableName);
        gr.addQuery('element', fieldName);
        gr.addQuery('element', 'NOT STARTSWITH', 'u_');
        gr.setLimit(1);
        gr.query();
        return gr.hasNext();
    },

    /**
     * Check reference fields for orphan references
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkReferenceFields: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = ctx.getTableName();
        var referenceFields = [];

        // Get all reference fields
        var gr = new GlideRecord('sys_dictionary');
        gr.addQuery('name', tableName);
        gr.addQuery('internal_type', 'reference');
        gr.query();

        while (gr.next()) {
            var fieldName = ctx.safeGetValue(gr, 'element');
            var refTable = ctx.safeGetValue(gr, 'reference');

            if (!fieldName || !refTable) continue;

            referenceFields.push({
                name: fieldName,
                reference_table: refTable
            });

            // Check if referenced table exists
            var tableGr = new GlideRecord('sys_db_object');
            if (!tableGr.get('name', refTable)) {
                ctx.addIssue('INVALID_REFERENCE', 'Field "' + fieldName + '" references non-existent table: ' + refTable, 'high', {
                    record_table: 'sys_dictionary',
                    record_sys_id: gr.getUniqueValue(),
                    category: 'field'
                });
            }
        }

        ctx.metrics.reference_field_count = referenceFields.length;
        ctx.metrics.reference_fields = referenceFields;
    },

    /**
     * Check business rules on the table
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkBusinessRules: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = ctx.getTableName();
        var businessRules = [];
        var activeBRCount = 0;
        var inactiveBRCount = 0;

        // Query business rules - collection field stores the table name
        var gr = new GlideRecord('sys_script');
        gr.addQuery('collection', tableName);
        gr.query();

        while (gr.next()) {
            // Check active field - can be 'true', '1', or boolean
            var activeVal = gr.getValue('active');
            var isActive = (activeVal === 'true' || activeVal === '1' || activeVal === true);

            var brInfo = {
                sys_id: gr.getUniqueValue(),
                name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                active: isActive,
                when: ctx.safeGetValue(gr, 'when'),
                order: ctx.safeGetValue(gr, 'order')
            };

            businessRules.push(brInfo);

            if (isActive) {
                activeBRCount++;
            } else {
                inactiveBRCount++;
            }
        }

        ctx.metrics.business_rules = businessRules;
        ctx.metrics.active_br_count = activeBRCount;
        ctx.metrics.inactive_br_count = inactiveBRCount;

        if (activeBRCount > 20) {
            ctx.addIssue('MANY_BUSINESS_RULES', 'Table has ' + activeBRCount + ' active business rules. This may impact performance.', 'medium', {
                record_table: 'sys_script',
                record_filter: 'collection=' + tableName + '^active=true',
                category: 'business_rule'
            });
        }

        if (inactiveBRCount > 10) {
            ctx.addIssue('INACTIVE_BUSINESS_RULES', 'Table has ' + inactiveBRCount + ' inactive business rules. Consider removing them.', 'low', {
                record_table: 'sys_script',
                record_filter: 'collection=' + tableName + '^active=false',
                category: 'business_rule'
            });
        }
    },

    /**
     * Check client scripts on the table
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkClientScripts: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = ctx.getTableName();
        var clientScripts = [];

        var gr = new GlideRecord('sys_script_client');
        gr.addQuery('table', tableName);
        gr.addQuery('active', true);
        gr.query();

        while (gr.next()) {
            clientScripts.push({
                name: ctx.safeGetValue(gr, 'name') || 'Unnamed',
                type: ctx.safeGetValue(gr, 'type'),
                ui_type: ctx.safeGetValue(gr, 'ui_type')
            });
        }

        ctx.metrics.client_scripts = clientScripts;
        ctx.metrics.client_script_count = clientScripts.length;

        if (clientScripts.length > 15) {
            ctx.addIssue('MANY_CLIENT_SCRIPTS', 'Table has ' + clientScripts.length + ' active client scripts. This may impact user experience.', 'medium', {
                record_table: 'sys_script_client',
                record_filter: 'table=' + tableName + '^active=true',
                category: 'client_script'
            });
        }
    },

    /**
     * Check children tables (if include_children_tables option is enabled)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _checkChildrenTables: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = ctx.getTableName();
        var childrenTables = [];

        // Get the sys_id of the parent table
        var parentGr = new GlideRecord('sys_db_object');
        if (!parentGr.get('name', tableName)) return;

        var parentSysId = parentGr.getUniqueValue();

        // Find all tables that extend this table
        var gr = new GlideRecord('sys_db_object');
        gr.addQuery('super_class', parentSysId);
        gr.query();

        while (gr.next()) {
            var childName = ctx.safeGetValue(gr, 'name');
            var childLabel = ctx.safeGetValue(gr, 'label') || childName;

            // Get record count for child table
            var childCount = 0;
            try {
                var ga = new GlideAggregate(childName);
                ga.addAggregate('COUNT');
                ga.query();
                if (ga.next()) {
                    childCount = parseInt(ga.getAggregate('COUNT'), 10) || 0;
                }
            } catch (e) {
                // Table might not be accessible
            }

            childrenTables.push({
                sys_id: gr.getUniqueValue(),
                name: childName,
                label: childLabel,
                record_count: childCount,
                scope: ctx.safeGetValue(gr, 'sys_scope')
            });
        }

        ctx.metrics.children_tables = childrenTables;
        ctx.metrics.children_table_count = childrenTables.length;

        if (childrenTables.length > 10) {
            ctx.addIssue('MANY_CHILD_TABLES', 'Table has ' + childrenTables.length + ' child tables. Consider reviewing table hierarchy.', 'low', {
                record_table: 'sys_db_object',
                record_filter: 'super_class=' + parentSysId,
                category: 'table'
            });
        }
    },

    /**
     * Analyze reference field data quality (if analyze_references option is enabled)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _analyzeReferenceData: function(ctx) {
        if (!ctx.metrics.table_exists) return;
        if (!ctx.metrics.reference_fields || ctx.metrics.reference_fields.length === 0) return;

        var tableName = ctx.getTableName();
        var totalRecords = ctx.metrics.record_count || 0;
        var referenceAnalysis = [];

        ctx.metrics.reference_fields.forEach(function(refField) {
            var fieldName = refField.name;
            var refTable = refField.reference_table;

            // Check for orphan references (references to deleted records)
            var orphanCount = 0;
            var nullCount = 0;

            try {
                // Count null references
                var gaNulls = new GlideAggregate(tableName);
                gaNulls.addNullQuery(fieldName);
                gaNulls.addAggregate('COUNT');
                gaNulls.query();
                if (gaNulls.next()) {
                    nullCount = parseInt(gaNulls.getAggregate('COUNT'), 10) || 0;
                }

                // Sample check for orphans (check first 1000 records)
                var gr = new GlideRecord(tableName);
                gr.addNotNullQuery(fieldName);
                gr.setLimit(1000);
                gr.query();

                while (gr.next()) {
                    var refValue = gr.getValue(fieldName);
                    if (refValue) {
                        var refGr = new GlideRecord(refTable);
                        if (!refGr.get(refValue)) {
                            orphanCount++;
                        }
                    }
                }
            } catch (e) {
                // Skip on error
            }

            var analysis = {
                field: fieldName,
                reference_table: refTable,
                null_count: nullCount,
                null_percentage: totalRecords > 0 ? Math.round((nullCount / totalRecords) * 100) : 0,
                orphan_count: orphanCount,
                orphan_detected: orphanCount > 0
            };
            referenceAnalysis.push(analysis);

            if (orphanCount > 0) {
                ctx.addIssue('ORPHAN_REFERENCES', 'Field "' + fieldName + '" has orphan references (at least ' + orphanCount + ' found in sample)', 'medium', {
                    record_table: tableName,
                    record_filter: fieldName + 'ISNOTEMPTY',
                    category: 'field'
                });
            }
        });

        ctx.metrics.reference_analysis = referenceAnalysis;
    },

    /**
     * Deep scan scripts for quality issues (if deep_scan option is enabled)
     * @private
     * @param {Object} ctx - Analysis context
     */
    _deepScanScripts: function(ctx) {
        if (!ctx.metrics.table_exists) return;

        var tableName = ctx.getTableName();
        var scriptIssues = [];
        var self = this;

        // Scan Business Rules
        var gr = new GlideRecord('sys_script');
        gr.addQuery('collection', tableName);
        gr.addQuery('active', true);
        gr.query();

        while (gr.next()) {
            var script = ctx.safeGetValue(gr, 'script');
            var brName = ctx.safeGetValue(gr, 'name') || 'Unnamed';
            var issues = self._analyzeScript(script, brName, 'Business Rule');
            scriptIssues = scriptIssues.concat(issues);
        }

        // Scan Client Scripts
        var csGr = new GlideRecord('sys_script_client');
        csGr.addQuery('table', tableName);
        csGr.addQuery('active', true);
        csGr.query();

        while (csGr.next()) {
            var csScript = ctx.safeGetValue(csGr, 'script');
            var csName = ctx.safeGetValue(csGr, 'name') || 'Unnamed';
            var csIssues = self._analyzeScript(csScript, csName, 'Client Script');
            scriptIssues = scriptIssues.concat(csIssues);
        }

        ctx.metrics.script_issues = scriptIssues;
        ctx.metrics.script_issue_count = scriptIssues.length;

        // Add issues for each script problem found
        scriptIssues.forEach(function(issue) {
            ctx.addIssue(issue.code, issue.message, issue.severity, {
                category: 'script'
            });
        });
    },

    /**
     * Analyze a script for common issues
     * @private
     */
    _analyzeScript: function(script, scriptName, scriptType) {
        var issues = [];
        if (!script) return issues;

        // Check for GlideRecord without limit in loops
        if (script.indexOf('GlideRecord') > -1 && script.indexOf('.query()') > -1) {
            if (script.indexOf('setLimit') === -1 && script.indexOf('get(') === -1) {
                // Check if it's in a while loop without limit
                if (script.indexOf('while') > -1 && script.indexOf('.next()') > -1) {
                    issues.push({
                        code: 'QUERY_NO_LIMIT',
                        message: scriptType + ' "' + scriptName + '" has GlideRecord query without setLimit()',
                        severity: 'medium'
                    });
                }
            }
        }

        // Check for current.update() in Business Rules (can cause infinite loops)
        if (scriptType === 'Business Rule' && script.indexOf('current.update()') > -1) {
            issues.push({
                code: 'CURRENT_UPDATE',
                message: scriptType + ' "' + scriptName + '" uses current.update() which can cause recursion',
                severity: 'high'
            });
        }

        // Check for hardcoded sys_ids (32 hex characters)
        // Pattern matches: "abc123...", 'abc123...', or just abc123... in addQuery/get calls
        var sysIdPattern = /['"]\s*[a-fA-F0-9]{32}\s*['"]/g;
        var sysIdMatches = script.match(sysIdPattern);
        if (sysIdMatches && sysIdMatches.length > 0) {
            issues.push({
                code: 'HARDCODED_SYSID',
                message: scriptType + ' "' + scriptName + '" contains ' + sysIdMatches.length + ' hardcoded sys_id value(s)',
                severity: 'medium'
            });
        }

        // Check for console.log (should use gs.log in ServiceNow)
        if (script.indexOf('console.log') > -1) {
            issues.push({
                code: 'CONSOLE_LOG',
                message: scriptType + ' "' + scriptName + '" uses console.log instead of gs.log',
                severity: 'low'
            });
        }

        // Check for eval() usage (security risk)
        if (script.indexOf('eval(') > -1) {
            issues.push({
                code: 'EVAL_USAGE',
                message: scriptType + ' "' + scriptName + '" uses eval() which is a security risk',
                severity: 'high'
            });
        }

        // Check for synchronous GlideAjax calls
        if (script.indexOf('GlideAjax') > -1 && script.indexOf('getXMLWait') > -1) {
            issues.push({
                code: 'SYNC_AJAX',
                message: scriptType + ' "' + scriptName + '" uses synchronous GlideAjax (getXMLWait)',
                severity: 'medium'
            });
        }

        return issues;
    },

    type: 'FHCheckTable'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-02 23:20:59</sys_created_on>
        <sys_id>99f80240835a321083e1b4a6feaad361</sys_id>
        <sys_mod_count>4</sys_mod_count>
        <sys_name>FHCheckTable</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_99f80240835a321083e1b4a6feaad361</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-04 08:21:32</sys_updated_on>
    </sys_script_include>
</record_update>
