<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1310794_founda_0.FHScanUtils</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>FHScanUtils</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var FHScanUtils = Class.create();
FHScanUtils.prototype = {
    initialize: function() {
        // Cache per execution instance
        this.cache = {
            bySysId: {}, // { table: { sys_id: plainObject } }
            query: {} // { cacheKey: [plainObjects] }
        };
    },

    // === Basic helpers ===
    toBool: function(value) {
        return value === true || value === 'true' || value === '1' || value === 1;
    },

    safeGet: function(gr, field) {
        try {
            if (!gr) return '';
            var v = gr.getValue(field);
            return v === null || typeof v === 'undefined' ? '' : String(v);
        } catch (e) {
            return '';
        }
    },

    getRecordBySysId: function(table, sysId, fields) {
        if (!table || !sysId) return null;
        this.cache.bySysId[table] = this.cache.bySysId[table] || {};
        if (this.cache.bySysId[table][sysId]) return this.cache.bySysId[table][sysId];

        var gr = new GlideRecord(table);
        var out = null;
        try {
            if (gr.get(sysId)) {
                out = {
                    sys_id: sysId
                };
                if (fields && Array.isArray(fields)) {
                    for (var i = 0; i < fields.length; i++) {
                        out[fields[i]] = this.safeGet(gr, fields[i]);
                    }
                } else {
                    // return a few common fields conservatively
                    out['name'] = this.safeGet(gr, 'name');
                }
            }
        } catch (e) {
            out = null;
        }
        this.cache.bySysId[table][sysId] = out;
        return out;
    },

    // === Generic query with optional memoization ===
    // buildQueryFn(gr) should modify the GlideRecord (addQuery, addNotNullQuery, setLimit, etc)
    getRecords: function(table, buildQueryFn, fields, limit, cacheKey) {
        cacheKey = cacheKey || table + '|' + (buildQueryFn ? '' : 'all');
        if (this.cache.query[cacheKey]) return this.cache.query[cacheKey].slice(0);

        var results = [];
        var gr = new GlideRecord(table);
        try {
            if (typeof buildQueryFn === 'function') buildQueryFn(gr);
            if (limit && typeof gr.setLimit === 'function') gr.setLimit(limit);
            gr.query();
            while (gr.next()) {
                var obj = {
                    sys_id: gr.getUniqueValue()
                };
                if (fields && Array.isArray(fields)) {
                    for (var i = 0; i < fields.length; i++) {
                        try {
                            obj[fields[i]] = this.safeGet(gr, fields[i]);
                        } catch (e) {
                            obj[fields[i]] = '';
                        }
                    }
                } else {
                    // minimal shape
                    obj.name = this.safeGet(gr, 'name') || '';
                }
                results.push(obj);
            }
        } catch (e) {
            // swallow errors to keep scanning resilient
            results = [];
        }
        this.cache.query[cacheKey] = results;
        return results.slice(0);
    },

    // Helper to build an "IN" query safely for an array of values (prevents empty IN)
    addInQuery: function(gr, field, values) {
        if (!values || !values.length) return;
        if (values.length === 1) {
            gr.addQuery(field, values[0]);
        } else {
            var qc = gr.addQuery(field, values[0]);
            for (var i = 1; i < values.length; i++) qc.addOrCondition(field, values[i]);
        }
    },

    // === Centralized script scanning: returns array of {kind, sys_id, name, script, source_table, record_table, ...} ===
    scanScriptsForTables: function(tables, options) {
        options = options || {};
        var types = options.types || ['business_rule', 'client_script', 'scheduled', 'transform_map', 'transform_entry', 'scripted_rest'];
        var results = [];

        // Business Rules (sys_script)
        if (types.indexOf('business_rule') > -1) {
            var brs = this.getRecords('sys_script', function(gr) {
                gr.addQuery('collection', 'IN', tables.join(','));
                gr.addQuery('active', true);
                gr.addNotNullQuery('script');
            }, ['name', 'script', 'collection'], 0, 'brs:' + tables.join(','));
            for (var i = 0; i < brs.length; i++) {
                results.push({
                    kind: 'Business Rule',
                    record_table: 'sys_script',
                    sys_id: brs[i].sys_id,
                    name: brs[i].name || 'Unnamed',
                    script: brs[i].script || '',
                    source_table: brs[i].collection || ''
                });
            }
        }

        // Client Scripts (sys_script_client)
        if (types.indexOf('client_script') > -1) {
            var css = this.getRecords('sys_script_client', function(gr) {
                gr.addQuery('table', 'IN', tables.join(','));
                gr.addQuery('active', true);
                gr.addNotNullQuery('script');
            }, ['name', 'script', 'table'], 0, 'csc:' + tables.join(','));
            for (var j = 0; j < css.length; j++) {
                results.push({
                    kind: 'Client Script',
                    record_table: 'sys_script_client',
                    sys_id: css[j].sys_id,
                    name: css[j].name || 'Unnamed',
                    script: css[j].script || '',
                    source_table: css[j].table || ''
                });
            }
        }

        // Scheduled jobs with scripts (sysauto_script)
        if (types.indexOf('scheduled') > -1) {
            var jobs = this.getRecords('sysauto_script', function(gr) {
                gr.addNotNullQuery('script');
            }, ['name', 'script', 'active'], options.sampleLimit || 0, 'jobs:script');
            for (var k = 0; k < jobs.length; k++) {
                results.push({
                    kind: 'Scheduled Job',
                    record_table: 'sysauto_script',
                    sys_id: jobs[k].sys_id,
                    name: jobs[k].name || 'Unnamed',
                    script: jobs[k].script || '',
                    active: jobs[k].active || 'false'
                });
            }
        }

        // Transform maps (sys_transform_map) -> map scripts (onBefore/onAfter) and transform entries
        if (types.indexOf('transform_map') > -1 || types.indexOf('transform_entry') > -1) {
            var tms = this.getRecords('sys_transform_map', function(gr) {
                gr.addQuery('target_table', 'IN', tables.join(','));
                gr.addNotNullQuery('script');
            }, ['name', 'script', 'target_table', 'active'], 0, 'transform:map:' + tables.join(','));
            for (var m = 0; m < tms.length; m++) {
                results.push({
                    kind: 'Transform Map',
                    record_table: 'sys_transform_map',
                    sys_id: tms[m].sys_id,
                    name: tms[m].name || 'Unnamed',
                    script: tms[m].script || '',
                    source_table: tms[m].target_table || ''
                });
            }
            // transform entries (map scripts on field/transform)
            if (types.indexOf('transform_entry') > -1) {
                var entries = this.getRecords('sys_transform_entry', function(gr) {
                    gr.addQuery('map.target_table', 'IN', tables.join(','));
                    gr.addNotNullQuery('script');
                }, ['name', 'script', 'map'], 0, 'transform:entry:' + tables.join(','));
                for (var e = 0; e < entries.length; e++) {
                    results.push({
                        kind: 'Transform Entry',
                        record_table: 'sys_transform_entry',
                        sys_id: entries[e].sys_id,
                        name: entries[e].name || 'Unnamed',
                        script: entries[e].script || '',
                        source_map: entries[e].map || ''
                    });
                }
            }
        }

        // Scripted REST / Scripted web services (sys_ws_operation / rest_operation)
        if (types.indexOf('scripted_rest') > -1) {
            var rps = this.getRecords('sys_ws_operation', function(gr) {
                // operation_script can contain table names or API references
                gr.addNotNullQuery('operation_script');
            }, ['name', 'operation_script', 'http_method', 'active'], 0, 'rest:scripted');
            for (var r = 0; r < rps.length; r++) {
                var scriptText = rps[r].operation_script || '';
                // Only include if any table name appears in script
                var include = false;
                for (var t = 0; t < tables.length; t++) {
                    if (scriptText.indexOf(tables[t]) > -1) {
                        include = true;
                        break;
                    }
                }
                if (include) {
                    results.push({
                        kind: 'Scripted REST',
                        record_table: 'sys_ws_operation',
                        sys_id: rps[r].sys_id,
                        name: rps[r].name || 'Unnamed',
                        script: scriptText,
                        http_method: rps[r].http_method || ''
                    });
                }
            }
        }

        return results;
    },

    // === Script pattern analysis ===
    // Returns list of issue objects: { type, name, code, message, severity }
    analyzeScriptPatterns: function(script, name, scriptType) {
        var issues = [];
        if (!script || !script.length) return issues;

        // Normalize for basic checks
        var s = String(script);

        // 1) GlideRecord query without limit pattern
        if (s.indexOf('GlideRecord') > -1 && s.indexOf('.query(') > -1) {
            if (s.indexOf('setLimit(') === -1 && s.indexOf('.get(') === -1) {
                if (s.indexOf('while') > -1 && s.indexOf('.next()') > -1) {
                    issues.push({
                        type: scriptType,
                        name: name,
                        code: 'QUERY_NO_LIMIT',
                        message: scriptType + ' "' + name + '" contains a GlideRecord query without setLimit() or explicit get().',
                        severity: 'medium'
                    });
                }
            }
        }

        // 2) Hardcoded sys_id (32 hex)
        var sysIdPattern = /['"]\s*[a-fA-F0-9]{32}\s*['"]/g;
        var sysIdMatches = s.match(sysIdPattern);
        if (sysIdMatches && sysIdMatches.length > 0) {
            issues.push({
                type: scriptType,
                name: name,
                code: 'HARDCODED_SYSID',
                message: scriptType + ' "' + name + '" contains ' + sysIdMatches.length + ' hardcoded sys_id value(s).',
                severity: 'medium'
            });
        }

        // 3) gs.sleep usage
        if (s.indexOf('gs.sleep') > -1) {
            issues.push({
                type: scriptType,
                name: name,
                code: 'GS_SLEEP',
                message: scriptType + ' "' + name + '" uses gs.sleep() which can impact performance.',
                severity: 'medium'
            });
        }

        // 4) eval usage
        if (s.indexOf('eval(') > -1) {
            issues.push({
                type: scriptType,
                name: name,
                code: 'EVAL_USAGE',
                message: scriptType + ' "' + name + '" uses eval() - security risk.',
                severity: 'high'
            });
        }

        // 5) Usage of server->client direct logging or large string concatenation (heuristic)
        if (s.indexOf('gs.print') > -1 || s.indexOf('console.log') > -1) {
            issues.push({
                type: scriptType,
                name: name,
                code: 'LOGGING_USAGE',
                message: scriptType + ' "' + name + '" contains console/gs.print logging; confirm debug left intentionally.',
                severity: 'low'
            });
        }

        return issues;
    },

    /**
     * addCategoryAndMetrics(ctx, categoryKey, itemKey, label, items, options)
     * Simplified version: uses only categories structure, no metrics
     *
     * - categoryKey: 'automation' | 'integration' | 'table' | 'security' ...
     * - itemKey: short key for this item group (e.g. 'rest_apis', 'transform_maps')
     * - label: human label shown in UI (e.g. 'REST APIs')
     * - items: array of plain objects representing records
     * - options: { table, icon, color }
     *
     * This will:
     *  - call ctx.registerCategory(categoryKey, label, icon) if category not present
     *  - call ctx.addCategoryItems(categoryKey, itemKey, label, items, options)
     *  - All counts and stats are handled by ctx.addCategoryItems internally
     */
    addCategoryAndMetrics: function(ctx, categoryKey, itemKey, label, items, options) {
        options = options || {};
        var meta = {
            table: options.table || '',
            icon: options.icon || '',
            color: options.color || '',
            success: false
        };

        try {
            var itemsArray = items || [];
            if (!Array.isArray(itemsArray)) itemsArray = [itemsArray];

            // Register category if not exists (do not override existing label/icon)
            if (ctx.registerCategory && typeof ctx.registerCategory === 'function') {
                var existingCat = ctx.getCategory && ctx.getCategory(categoryKey);
                var catLabel = existingCat && existingCat.label ? existingCat.label : (label || categoryKey);
                var catIcon = existingCat && existingCat.icon ? existingCat.icon : (options.icon || 'fa-folder');
                ctx.registerCategory(categoryKey, catLabel, catIcon);
            }

            // Add items to category
            if (ctx.addCategoryItems && typeof ctx.addCategoryItems === 'function') {
                ctx.addCategoryItems(categoryKey, itemKey, label, itemsArray, {
                    table: options.table,
                    icon: options.icon,
                    color: options.color
                });
                meta.success = true;
            } else {
                gs.error('addCategoryAndMetrics: ctx.addCategoryItems is not available');
                meta.success = false;
                meta.error = 'addCategoryItems not available';
            }

            // Special handling for table_summary: store exists and record_count in category metadata
            // if (itemKey === 'table_summary' && itemsArray.length === 1) {
            //     var summary = itemsArray[0];
            //     var category = ctx.getCategory && ctx.getCategory(categoryKey);
            //     if (category) {
            //         if (typeof summary.exists !== 'undefined') {
            //             category.exists = !!summary.exists;
            //         }
            //         if (typeof summary.record_count !== 'undefined') {
            //             category.record_count = summary.record_count;
            //         }
            //     }
            // }

        } catch (e) {
            gs.error('addCategoryAndMetrics error: ' + e);
            meta.success = false;
            meta.error = '' + e;
        }

        return meta;
    },

    /**
     * Check if a record is a ServiceNow base record (admin / glide.maint creation and not modified by others)
     * @param {Object} obj - record with sys_created_by/sys_updated_by
     */
    isSncRecord: function(obj) {
        if (!obj) return false;
        var sncUsers = {
            'admin': true,
            'glide.maint': true,
            'GUEST': true,
            'system': true,
            'don goodliffe': true,
            'maint': true,
            'chris.henson': true
        };
        var created = (obj.sys_created_by || '').toLowerCase();
        var updated = (obj.sys_updated_by || '').toLowerCase();
        var createdSNC = sncUsers[created];
        var updatedSNC = sncUsers[updated] || updated === '';
        return createdSNC && (!updated || updatedSNC);
    },

    /**
     * Filter out ServiceNow base records if option enabled
     * @param {Array} list
     * @param {Object} opts { ignoreSnc: boolean }
     */
    filterOutSncRecords: function(list, opts) {
        if (!opts || !opts.ignoreSnc) return list || [];
        var self = this;
        return (list || []).filter(function(r) {
            return !self.isSncRecord(r);
        });
    },


    type: 'FHScanUtils'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2026-01-04 18:06:27</sys_created_on>
        <sys_id>df241fac8352761083e1b4a6feaad360</sys_id>
        <sys_mod_count>6</sys_mod_count>
        <sys_name>FHScanUtils</sys_name>
        <sys_package display_value="Foundation Health Analyzer" source="x_1310794_founda_0">d852994c8312321083e1b4a6feaad3e6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Foundation Health Analyzer">d852994c8312321083e1b4a6feaad3e6</sys_scope>
        <sys_update_name>sys_script_include_df241fac8352761083e1b4a6feaad360</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2026-01-05 03:37:09</sys_updated_on>
    </sys_script_include>
</record_update>
